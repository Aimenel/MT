\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}

\begin{document}
\maketitle
\newpage
\section{Abstract}
\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs including shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} assosciate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a randomn access pattern in an array.

The paper Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language Silver. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Silver handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express pointwise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adpation of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

...section . deals with .

\section{Background}
%viper, silver, carbon, silicon
\subsubsection{Quantified Field Permissions}
\subsubsection{Predicates}
\subsubsection{Magic Wands}
\section{Quantified Predicates}
\section{Quantified Wands}
\section{Combinations of Quantifiers}
\section{Nested Quantifiers}
\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}