\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}
\usepackage{listings}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Abstract}
\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs including shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} assosciate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a randomn access pattern in an array.

The paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language Silver. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Silver handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express pointwise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adpation of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

...section . deals with .

\section{Background}
%Permissions in general
In this chaper we give an overview of the theory needed to understand the proposed generalisation of quantified permissions, which is intended as an extenstion to the support already integrated in Viper\cite{viper}.

Viper is an verification infrastructure for permission-based reasoning and enables the development of program verifiers based on permission logics. It is designed to facilitates the implementation of verification techniques for programs, allowing developers to focus on the abstraction of higher-level language features to its intermediate verifcation language. Currenlty, it includes an intermediate verification language \textit{Silver}, two automatic back-end verifiers based on it and several front-ends for programming languages.

Permission logics were designed to define which locations of a heap are accessible. Viper works with fractional permissions between 0 and 1, where 1 denotes full permissions, which is equal to write and read permission, and any permission greater than 0 allowing to read values of a location. Both permissions and values of a location are stored in a heap chunk. When checking whether we posess enough permission for a specific location, we iterate through the heap chunks.
Assertions may only depend on locations with permission. Reaoning abuot properties can be reduced to inhaling and exhaling assertions. Inhaling is equal to adding the permission denoted or an assume in case of a pure assertion. Exhaling translates to removing permission or asserting a property in case of a pure assertion. If the permission of a location is lost, we also lose information about its value.

The two back-end verifiers are called \textit{Carbon} and \textit{Silicon}. 

\textit{Carbon}  is based on verification condition generation. It translates the given silver program to Boogie\cite{leino2008boogie}, which proves the generated code.%continue

\textit{Silicon} is based on symbolic execution. It is based on the SMT solver Z3\cite{de2008z3} and Smallfoot-style Symbolic Execution\cite{berdine2005smallfoot}, where the symbolic state is stored in heap chunks, holding permission and values for specific locations, and path conditions holding properties obtained while evaluating or executing commands.
%Smallfoot-style Symbolic Execution: In successor tools: VeriFast, jSTar and Viper: heap chunks also predicates...

\subsection{Silver}
overview of syntax
%fields, methods, functions, predicates, custom domains.

\subsection{Recursive Predicates}
Recursive Predicates\cite{parkinson2005separation} are typically used as part of separation logic to specify linked data structures such as lists and trees. Its definition consists of a name, a list of formal parameters and a body. The permission of the predicate may be exchanged for its body via \textit{unfold}, whereas \textit{fold} exchanges the properties of the body for the permission of the predicate. Additionally, \textit{unfolding} additionally allows to temporarily unfold a predicate.

%TODO: example please. Explicit task thing for unfolding, folding a predicate
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
inhale acc(pred(arg1, ..., argn)):\\
assume permission at most p?\\
generate snap\\
add predicate chunk
}}

\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
exhale acc(pred(arg1, ..., argn)):\\
assert p not negative\\
assert enough permission\\
remove predicate chunk\\
add predicate chunk with remaining permission if any
}}

\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
unfold acc(pred(arg1, ..., argn):\\
assert perm nonnegative\\
consume predicate permission: generates snap\\
produce predicate with obtained snap 
}}


\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
fold pred(arg1, ..., argn):\\
assume permission at most p\\
consume body: obtain snap of chunk\\
produce predicate chunk\\
}}



\subsection{Magic Wands}
A magic wand\cite{magicwand} A --* B is a binary connective, which allows that given assertion A is satisfied in the current state, it can be exchanged for the assertion B. Similarly to recursive predicates, the exchange can be initiated by \textit{apply}, whereas \textit{unapply} exchanges assertion B for assertion A. Viper also supports a heuristic to automate when these assertions are exchanged. This functionality can be used to keep track of partial data structures during a traversal.

%example please. Explain more closely how apply and unapply work. Cite other stuff?

%Quantified Field Permissions
\subsection{Quantified Field Permissions}
The generalisation of quantified permissions as defined before is building on top of the concept presented for quantified field permissions of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}.
It defines a new definition for quantified heap chunks and an approach to inhale and exhale quantified field permissions.

%Quantified Field Chunk
\paragraph{Quantified Field Chunk}
Heap chunks are generalised to denote permission to an unbounded number of locations simultaneously.
In order to avoid an existential query in making a quantified permission chunk depending on the variable of the original forall expression, an inverse function is introduced, which maps a location to the initial value of the variable. To guarantee the existence of an inverse function, it is necessary that the expression denoting the receiver must be injective, which does however not restrict the data structures that can be handled by this approach as long as correctly specified.This allows us to define a quantified permission chunk of the form r.f -> [v(r), p(r)], where r represents the quantified receiver, p(r) an expression denoting the permission amount and v(r) a value map used to hold the values of the locations.
General form: r.f -> [v(r), c(inv(r)) ? p(inv(r)) : 0)]

%Inhale
\paragraph{Inhale}
Given a symbolic heap, a path condition and a quantified field permission, inhaling returns an updated heap and path conditions.
Inhaling generates a new quantified heap chunks  r.f -> [v(r), c(inv(r)) ? p(inv(r)) : 0)] after evaluating the condition, receiver expression and permission expression, as well as introducing the inverse function inv and a fresh value map v(r).
The inverse function is only defined if the given condition c(x) or c(inv(r)) holds.The definition adds two quantified conditions to the path condition starting from a general location and the original variable types variable.

%injectivity

%Exhale
\paragraph{Exhale}
Exhaling again evaluates the condition, receiver expression and permission expression, checks the injectivity of the receiver expression, introduces its inverse function and proceeds to remove the permission from the heap.
The removing is done by walking through all quantified field chunks with the same field f, removing permissions greedily or fails if there is not enough permission. Updating chunks is expressed via pointwise-defined functions defining the permission amounts.

%Quantified Fields inverse function and injectivity definitions.
\begin{tabular}{ l || c }
& Quantified Field Permission \\ \hline
General Form & \( \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(e(x).f, p(x)) \)  \\
Inverse Functions &   \( \mathbf{forall} \   x:T :: c(x) \Rightarrow inv(e(x)) == x \) \\
& \( \mathbf{forall} \   r:Ref :: c(inv(r)) \Rightarrow e(inv(r)) == r \) \\
Injectivity &  \( \mathbf{forall} \   x_1:T, x_2:T :: (x_1 != x_2)\ \&\& c(x_1) \ \&\& c(x_2)  \Rightarrow e(x_1) != e(x_2) \)\\ \hline
\end{tabular}

%formulas defining inhale, exhale, remove


\section{Quantified Predicate Permissions}
For the support of quantified predicates, we can adapt the approach mentioned for Field Chunks. The main difference is, that predicates can have multiple arguments. As a concequence, the definitions for the inverse function, as well as the injectivity have to be changed. 

%General Form. Why that form


\subsection{General Approach}
%Mini-Introduction?

%Technical Challenges of it
We explain the technical challenges involved in answering the following questions:
\begin{enumerate}
\item How to model the program state, including permissions and values?
\item How to check for a permission in a state?
\item How to add and remove permissions to and from a state?
\item How to evaluate (heap-dependent) expressions in a state?
\item When to preserve (frame) an expression's value across heap changes?
\end{enumerate}
%Example

\subsubsection{Adaption to state}
In order to reason about quantified predicate permissions, it is necessary to define a symbolic heap representation for a potentially unbound set of predicates simultaneously. 

Our design combines the solution presented for quantified field chunks and predicate chunks. Contrary to a quantified field chunk, a general representation of a predicate is depending on its arguements instead of a generalized location reference, whereas the predicate name takes the place of the field name. As a consequence the generalisation of a predicate chunk is defined per predicate name, whereas the permission and values are depending on its arguments.

Anagolous to the quantified chunk representation mentioned before it is necessary to define a inverse function  in order to express the condition and permission amount for the predicate with general arguemtns. This inverse function returns the value of the quantifier variable of the original variable. As a result we have to restrict the allowed expression terms in the form of predicates. The comibnation of the expressions has to be injective.

%value funciton replaced

%general form
%where does the snapshot come from

%Quantified Predicate
\begin{tabular}{ l || c }
& Quantified Predicate Permission \\ \hline
General Form & \( \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(pred(e_1 (x),…,e_n (x)), p(x)) \)  \\
Inverse Functions &   \( \mathbf{forall} \   x:T :: c(x) \Rightarrow inv(e_1 (x),…,e_n (x))==x \) \\
& \( \mathbf{forall} \  arg_1:T_1,…,arg_n:T_n ::  c(inv(arg_1, …,arg_n ))  \) \\
& \(\Rightarrow e_i (inv(arg_1, ..., arg_n )) == arg_i \) \\
Injectivity &  \( \mathbf{forall} \   x_1:T, x_2:T :: (x_1 != x_2)\ \&\& c(x_1) \ \&\& c(x_2)\)  \\
&\( \Rightarrow e_1(x_1) != e_1(x_2) || ... || (e_n(x_1) != e_n(x_2) \)\\ 
Heap Chunk &  \( \mathbf{pred}(arg_1, ...., arg_n)\mapsto [s(arg_1, ...., arg_n),\) \\
&  \(c(inv(arg_1, ..., arg_n)) ? p(inv(arg_1, ..., arg_n))]\)\\ \hline
\end{tabular}

\subsection{checking permission}
Exhaling a quantified predicate permission

\subsection{Adding and removing permission}
Adding and removing permisisons are done by inhaling and exhaling respecitvely.

\subsubsection{Inhaling}
Inhaling a quantified predicate permission updates a given state and returns an updated heap and path condition.
As for the quantified field expression, the condition, argument expressions and permission expression are evaluated as a frist step, which may update the path condition. 

The inverse function is intorduced anagolous to a quantified field permission and further defined by adding two constraints to the path condition. Whereas a quantified field permission is depending on the variable of the given inhale expression and a fix reference as a general location, a quantified predicate permission may depend on multiple variables. As a consequence the cardinality of the inverse function may vary with differend predicates, whereas the definition and constraints are identical for the same predicates.

Instead of a value function, we introduce a function, which maps a concrete instantiation of a predicate defined by its arguements to the snap of the specific predicate. This snap value contains the values on which the predicate may rely on during an unfold or unfolding. On introduction, it models an unknown snapshot in the domain. %domain? what is it? 

\begin{lstlisting}
inhale(h_0, π_o, forall x:T :: c(x) => acc(c(x).f, p(x))) 

var (
\end{lstlisting}


\subsubsection{Exhaling}
After evaluating the expressions denoted by the quantified predicate permission, we check the injectivity analogously to a quantified field permission before introducing the inverse functions as defined in the inhaling. For the injectivity check, it is sufficient that at least one argument expression differs on the evaluation of any two unequal variables satisfying the condition presented in the original statement. %Example

Removing the permission amount is done the same way as in the approach for quantified field permissions by iterating through all chunks, taking permission greedily, and raising an error if not enough permission is available.

\subsection{Treatment of Symbolic Values}
The predicate snapshot is used during unfold, fold and unfolding, where unfold corresponds to a field read and fold to field write in the context of a quantified field permission.

%overview

\subsubsection{Unfold}
Unfold exhales the permission to the predicate with given arguments as described above. Exhaling will provide you with the snapshot of the predicate, which is inhaled - containing permission and values designated by the snapshot.

\subsubsection{Fold}
Exhales the body of the predicate and stores its snapshot in the  snapshot function of the newly generated quantified predicate chunk.

\subsection{Unfolding}
Unfolding is desugared as before.

\subsection{Framing}

%silicon
\subsection{Silicon}
The implementation of Siilicon is very close to the approach presented in section 2.
Analogous to the quantified field permissions unquantified predicates are also treated as quantified permissions, where the permission is restricted to the specific predicate argument values.

\subsubsection{Producing multiple Quantified Predicates}
\begin{itemize}
\item create new quantified predicate heap chunk
\item declare inverse functions and two assumtpions declaring its properties as defined above.
\end{itemize}

Z3 Code-wise: The assumption of non-null fields is not necessary.

\subsubsection{Producing a single Quantified Predicate}


%Quantified Magic Wands
\section{Quantified Magic Wands}
A representation of a Magic Wand\cite{magicwand} depends on the form of de wand definition and may have multiple arguments. As a consequence, the definition for inverse funcitons and injectivity are analogous to a quantified predicate permission.

%example

%Quantifiers
\section{Combinations of Quantifiers}
In order to avoid declaring unnecessary forall expression with the condition or dependency, it is desirable to be able to express combinations of pure and permission-based specifications. We considered the following combinations:
\begin{itemize}
\item conjunction of any mix of pure and permission-based quantifiers:
%TODO link to specific definition
\begin{equation}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))),
\end{equation}
where {\it trs} are the triggers of the forall expression, {\it c(x)} is  a boolean expression,{\it e(x)} denotes an expression which could either be a pure expression or a permission expression depending on x, in which case {\it e(x)} consists of an injective mapping to a set of locations and some permission function {\it p(x)} as described in the chapters before.

\item implication of a boolean expression and a permission-based quantifier:
%TODO: link?
\begin{equation}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x)),
\end{equation}
with the same definitions of .
\end{itemize}

Please note that forall expressions which are entirely pure are not considered in this chapter.

%TODO

We considered two ways to expand the given approach to this setting: desugaring the forall expression to the form we defined before or adapt the interpretation to allow for such things. As it is, combinations may be depending on each other, which means each conjunction as to be evaluated sequentally. As a result there is barely any gain in not desugaring the terms mentioned before. Therefoe we suggest two rewriting rules to desugare conjunctions and implications within a forall expression.

\subsection{Rewriting Rules}
A conjunction of two expression is desugared by rewriting the entire forall expreeion into two forall expressions, dublicating variables, condition and triggers. Triggers are expected to be valid for both newly generated forall expressions.

\begin{equation}
\begin{aligned}
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x)  \Rightarrow e_1(x)) \ \&\& \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x) \Rightarrow  e_1(x))
\end{aligned}
\end{equation}

An implication is rewritten to the logical equivalent of the conjunction of both conditions on the left-hand side of the implication.
\begin{equation}
	\mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x))
\end{equation}

\subsection{Implementation}
The rewriting rules are implemented in the parser. As a result they are exectued for both Carbon and Silicon.

User-given triggers are handed over. Since suitability of the triggers is not tested for each rewritten forall expression, triggers need to suite all and clauses of an expression. Pure quantifiers are not rewritten. 

%TODO
 In Carbon, triggers are generated after the rewriting step in case of empty triggers.


\section{Nested Quantifiers}
\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}