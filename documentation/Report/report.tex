\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Zurich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{longtable}
\usepackage{silver}
\usepackage{pdfpages}

\lstset{
         numbers=left,
 }

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
  % basicstyle={\small\fontfamily{cmtt}\selectfont}
  % basicstyle={\ttfamily\selectfont\footnotesize},
  % commentstyle={\ttfamily\selectfont\footnotesize},
  tabsize=2,
  mathescape=true,
  language=silver
  % basicstyle=\ttfamily
}

\begin{document}
\pagenumbering{gobble}
\clearpage
\newcommand*{\ident}{\hspace*{0.5cm}}
\newcommand{\wand}{\ensuremath{\mathbin{-\!\!*}}}

\begin{titlepage}
	\includegraphics[width=6cm]{eth_logo_black.pdf}
	\vfill
	\centering
    \vspace*{1cm}
    \Huge\textbf{Generalised Verification for Quantified Permissions}

    \vspace*{2cm}
    \Large\textbf{Master Thesis}
    
    \vspace*{1cm}
    \Large Nadja M\"uller
    
    \vspace*{0.5cm}
    Supervised by Alexander Summers,\\
    Prof. Dr. Peter M\"uller \\
    Department of Computer Science \\
    ETH Zurich
    
    \vspace*{0.5cm}
    \today
    
	\vfill

    \raggedright
   	
\end{titlepage}

%\maketitle
%\includegraphics[width=6cm]{eth_logo_black.pdf}
\newpage

\clearpage
\pagenumbering{Roman}
\tableofcontents
\newpage
\clearpage
\pagenumbering{arabic}% Arabic page numbers (and reset to 1)
\section{Abstract}
The verification infrastructure Viper supports a quantified field permission of the form \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\). The quantifier may only depend on one variable and express permissions to a set of fields. Viper includes two verifiers. Carbon is based on verification condition generation, Silicon on Smallfoot-style symbolic execution. In this report, we present approaches for both types of verifiers to generalise the support of quantified permissions. We present a solution to adapt the approaches for quantified field permissions to support quantified predicate and magic wands permissions, as well as nested quantifiers. We also present rewriting rules for combining pure and permission-based quantifiers.We implemented both quantified predicate permissions and combinations of quantifiers in Carbon and Silicon.

\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs as shared mutable data structures, separation logic \cite{reynolds2002separation} and implicit frames \cite{smans2009implicit} associate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a random access pattern in an array.

The paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc} presented a solution to define permissions to a set of field locations regardless of the access pattern. It introduces a quantified heap chunk to hold the permissions and symbolic values for a set of fields simultaneously, as well as symbolic rules to evaluate specific values, remove and add permissions to quantified field chunks.

The approach was implemented in the verification infrastructure Viper \cite{viper}. It includes several front-ends which translate the given programs to Viper's intermediate language. These programs can be verified with Silicon, which is based on symbolic execution, and Carbon, a verification condition generator. There are currently three features of Viper handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structures and quantified field permissions \cite{isc} allows us to express point-wise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a Boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce new approaches adapting this solution to allow quantified permissions for predicates \cite{predicates} and magic wands \cite{magicwand} instead of fields, as well as  nested quantifiers. Further we present rewriting rules to get rid of the fix structure of quantified field permissions, allowing expressions not defining a condition \(c(x)\) and combinations of pure and permission-based quantifiers.

\subsection{Outline}

The following section presents an overview to Viper, including the approach integrated for quantified field permissions. Section \ref{genField} shows some minor changes for the treatment of quantified field permissions, including the support of user-given triggers in Carbon. The adapted approach for quantified predicate permissions is introduced in section \ref{qp}, the approach for quantified magic wand permissions in section \ref{qmw}. The rewriting rules for combinations of quantifiers are defined in section \ref{rewriting}. The adaption necessary to support nested quantifiers is described in section \ref{nq}. Finally, we evaluate the performance of the implementation of quantified predicates and combinations of predicates in section \ref{evaluation}. Additionally, the appendix holds a few examples of programs newly supported in Viper.

%to be continued

\section{Background}
\label{background}
%Permissions in general
In this chapter we give an overview of the theory needed to understand the proposed generalisation of quantified permissions. The generalisation is intended as an extension to the support for quantified fields already integrated in Viper \cite{viper}\cite{viper2014}.

Viper is a verification infrastructure for permission-based reasoning and enables the development of program verifiers based on permission logics. It is designed to facilitate the implementation of verification techniques for programs, allowing developers to focus on the encoding of higher-level language features into its intermediate verification language. It includes an intermediate verification language, two automatic back-end verifiers \textit{Carbon} and \textit{Silicon}, as well as several front-ends translating other programming languages to Viper for verification. For the generalisation we allow new quantified expressions in Viper. To support the verification of these, we adapted both Carbon and Silicon. 

\textit{Carbon}  is based on verification condition generation. It translates the given Viper program to Boogie \cite{leino2008boogie}, which proves the generated code.
In Carbon, the state is modelled by maps representing the heap and permissions held.

\textit{Silicon} is based on the SMT solver Z3 \cite{de2008z3} and Smallfoot-style Symbolic Execution \cite{berdine2005smallfoot}. The symbolic state is stored in heap chunks, holding permission and values for specific locations, and path conditions, which represent the properties obtained while evaluating or executing commands.

A Viper program consists of global declarations of fields, predicates, functions, methods, and custom domains. To represent unbounded heap structures, Viper supports the following concepts: Predicates, Magic Wands and Quantified Field Permissions.

%fields, methods, functions, predicates, custom domains.
\subsection{Permissions}
Permission logics were designed to define which locations of a heap are accessible. Viper works with fractional permissions with values between 0 and 1. Any permission greater than 0 grants read access to the corresponding field location, whereas 1 denotes full permission, which additionally allows write access to a location. 
In Viper, there are various constructs for representing permission. The one most used is the accessibility predicate acc\((e_1.f, e_2)\), denoting permission to a field location \textit{f} of the reference denoted by \(e_1\). The permission amount is expressed by \(e_2\). If the permission amount is omitted, the permission amount defaults to full permission. If an expression does not include any permission expression, it is called pure.

\subsection{Program State}
The program state of Viper includes the current permissions held, as well as the assignments to program variables. The state can be manipulated by assertions, which may only depend on locations to which permission is held. The process of verifying certain properties and updating the state during the execution of expressions can be reduced to checking, inhaling and exhaling assertions. Inhaling is equal to adding the designated permission amount if the expression represents a permission (e.g. acc\((e.f)\)), or assuming a property if the assertion is pure. Exhaling translates to removing permission or asserting the properties specified. If the permission to a location is lost, we also lose information about its value.
Carbon uses maps to describe the heap and permissions held. In Silicon, the state representation includes a set of heap chunks and path conditions.

\subsection{Types and Domains}
The built-in primitive types of Viper consist of integers (Int), Boolean expressions (Bool), references (Ref) and permissions (Perm). Additionally,  polymorphic sequences such as Seq[T] and sets Set[T] are included. Domains further allow the definition of custom domain types, which may include axioms and functions to define their properties. An example of a domain can be seen in Figure \ref{domainExample}.

\begin{figure}[h]
  \centering
\begin{lstlisting}
field val: Int

domain IArray {
  function loc(a: IArray, i: Int): Ref
  function len(a: IArray): Int

  axiom len_nonneg {
    forall a: IArray :: len(a) >= 0
  }
}
\end{lstlisting}
\caption[predicate example]
   {Example of a domain. The domain\(IArray\) represents an integer array and defines two function: \(loc\) returns the location of a specific value given an array and index, \(len\) the length of the given array. In addition to these functions, the axiom \(len\_nonneg\) defines that the length of an array has to be positive. The value of a location corresponds to \(loc(a, i).val\).}
\label{domainExample}
\end{figure}

\subsection{Fields}
Fields are globally defined and have a designated type. On declaration, the field exists for all references. In order to read a field value, a permission amount greater than 0 is necessary. When writing to a field, full permission is required.

\subsection{Methods}
Methods consist of a name, arguments (potentially including out-parameters), pre- and postconditions, as well as a method body. The preconditions must include sufficient permissions to allow all heap dereferences used in the method body. During verification, the verifiers inhale the preconditions and try to prove the postconditions after the execution of the body. If a method call is executed, the called method's precondition is exhaled. Subsequently, we gain the information defined by the postcondition by inhaling.

\subsection{Functions}
Similarly to methods, functions consist of a name, preconditions, postconditions and optionally a body. Contrary to methods, the expressions within the body are restricted and must be pure. Predicates may be used in assertions.

\subsection{Recursive Predicates}
%"Predicates can be used both to abstract over concrete assertions and to write recursive specifications of heap data structures."

Recursive Predicates \cite{parkinson2005separation} are typically used to specify linked data structures such as lists and trees. A predicate definition consists of a name,  list of formal parameters and a body. Since predicates can be recursive, as in Figure \ref{recursivePredicate}, and such a predicate could potentially be unrolled endlessly, Viper treats predicate instances as opaque. Permissions and the logical facts entailed by a predicate's body are not directly available to the verifier. We use ghost operations to obtain the logical facts from a predicate instance and vice versa.
A predicate instance may be exchanged for its body via \textit{unfold}, whereas \textit{fold} exchanges the properties of the body for an instance of the predicate. Additionally, \textit{unfolding} additionally allows the temporary unfolding of a predicate while evaluating a specified expression. An example using these ghost operations can be found in Figure \ref{predicateExample}.

%example recursive
\begin{figure}[h]
  \centering
\begin{lstlisting}
field val: Int
field next:Ref

predicate list(r:Ref)
{
    acc(r.val) && acc(r.next) && (r.next != null ==> list(r.next))
}
\end{lstlisting}
\caption[recursive predicate]
   {example of a recursive predicate definition}
\label{recursivePredicate}
\end{figure}


%example
\begin{figure}[h]
  \centering
\begin{lstlisting}
field f: Int

predicate pred(r:Ref)
{
    acc(r.f)
}

method m1(r:Ref)
requires acc(pred(r))
ensures acc(pred(r))
ensures unfolding pred(r) in r.f == 0
{

    unfold pred(r)
    r.f := 0
    fold pred(r)
}
\end{lstlisting}
\caption[predicate example]
   {Simple predicate example. By unfolding the predicate in line 14, we lose the access right to the predicate instance \textit{pred(r)} and gain the access rights to the field \textit{r.f}. This allows us to write to the field. By folding the predicate again, we regain the access rights to the predicate, which allows us no exhale the predicate in line 10. Unfolding temporarily unfolds the predicate \textit{pred(r)}, after which we obtain the permission to read the field \textit{r.f}, and also the value of that field. As a result, the assertion \textit{r.f == 0} evaluates to true.}
\label{predicateExample}
\end{figure}

\subsection{Magic Wands}
A magic wand A \(\wand\) B is a binary connective, which guarantees that if the given left-hand assertion A is satisfied in any state, then that assertion and the magic wand instance can be exchanged for the right-hand assertion B. The concept of magic wands was already mentioned in the first papers of separation logic \cite{reynolds2002separation} and can be used to keep track of partial data structures during a traversal.

A magic wand instance is created using its so-called \textit{footprint}, which is a subset of the current state that satisfies the wand's semantics. The footprint itself is not directly determined by its definition. The strategy of selecting a footprint in Viper is to include all permission required by the wands right-hand side, which we cannot prove to be provided by the wand's left-hand side \cite{magicwand}.

As for the concept of predicates, automatically reasoning about magic wands has been proven to be undecidable \cite{brochenin2008almighty}. As a consequence, Viper treats an instance of a magic wand as opaque. Exchanging the left-hand side of a magic wand with its right-hand side can be done with the ghost operation \textit{apply}. It is desugared to the following statements \cite{magicwand}:

\vbox{
\begin{longtable}{ p{0.99\textwidth} } 
 \textit{apply} \(A \wand B \longmapsto\) \\ 
\ident \textit{exhale} \(A \wand B \)\\
\ident \textit{exhale} \(A\)\\
\ident \textit{inhale} \(B\),\\
\end{longtable}
}
where \(\longmapsto\) represents a translation or rewriting step.

A second ghost operation \textit{package} \(A \wand B \) calculates a suitable footprint for the instance \(A \wand B \). The operation fails, if no such footprint can be found. Otherwise, the foorprint is then exchanged for a new wand instance.

%Quantified Field Permissions
\subsection{Quantified Field Permissions}
\label{qf}

The implementation of the quantified field permissions support depends on the verifier used. We first summarise how quantified field permissions are supported in the verification generator Carbon, and then explain the approach for symbolic execution, as presented in the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. 

The currently supported shape of quantified field permission expression is defined as:

\begin{equation}
\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))
\end{equation}

The Boolean expression \(c(x)\) denotes a condition, under which a set of fields, defined by the reference-typed expression \(e(x)\) and the field \(f\), gain the permission amount expressed in the permission-typed expression \(p(x)\). An example of a quantified field permission is displayed in Figure \ref{qfExample}.

\begin{figure}[h]
  \centering
\begin{lstlisting}
field f: Int

method m(r: Ref, xs:Seq[Ref])
requires r in xs
requires forall x: Ref :: x in xs ==> acc(x.f)
{
    r.f := 4
}
\end{lstlisting}
\caption[quantified field permission example example]
   {Quantified field permission example. By inhaling the permission to the field \(f\) for all references in the set \textit{xs}, we gain the permission necessary to set a new value for the field \(r.f\).}
\label{qfExample}
\end{figure}

\subsubsection{Verification Condition Generation and Quantified Field Permissions}
\label{cgqf}
In Carbon, field permissions are represented in the map \textit{Mask}. Inhaling a field permission \(x.f\) updates the permission map for the specified location denoted by \textit{Mask}\((x, f)\) and assumes  that the reference pointing to the field is non-null. In order to support quantified field permissions, it is therefore sufficient to introduce new translations for inhaling and exhaling quantified field permissions, which update the permission map \textit{Mask} for the denoted set of fields.
Inhaling and Exhaling field permissions, as well as reading or writing to a field is done as before.

\paragraph{Inhaling a Quantified Field Permission: }
In order to model the changes to the permission map \textit{Mask} as a bulk update, we create a new map \textit{qpMask} at the beginning of the translation, which replaces \textit{Mask} after completing the inhale operation. The permission amount of the new map needs to be defined for both updated and unaffected locations. This is done by translating the quantified field permission to several Boogie quantifiers. 

Potentiall, the assumption defining the values of the permission mask could be defined as \textbf{assume} \(\forall x:T :: \{?\}\ c(x) \Rightarrow qpMask[e(x), f] = Mask[e(x), f] + p(x)\), where the expression within the curly brackets represents the trigger, which allows this property for a specific value \(x'\) of type \(T\) to be available to the Boogie verifier. In Boogie, a trigger has to contain the quantifier variable and cannot only consist of a variable itself. The type of expressions allowed as a trigger is restricted as well. In order to trigger the permission update for all Mask accesses \(qpMask[r, f] \), this expression should be the trigger of the given expression, but is not a valid since  \(qpMask[r, f] \) does not contain the quantifier variable \(x\). 
In order to use this trigger, we express the same property for all references \(r\), which results in an assumption of the following form: \textbf{assume} \(\forall r:Ref :: \{qpMask[r, f]\} \dots \Rightarrow qpMask[r, f] = Mask[r, f] + p(\dots)\).

In order to translate the quantified field permission, we introduce an inverse function \(e^{-1}\), which maps a location \(r\) to the corresponding value of the original quantifier variable \(x\) of type \(T\). Using the inverse function we can check, whether a location is altered by the quantifier by evaluating the condition as \(c(e^{-1}(r))\). The gained permission is equal to \(p(e^{-1}(r))\). 
The introduction of the inverse function requires, that the expression \(e(x)\) has to be injective. When inhaling a quantified field permission, the injectivity of \(e(x)\) is assumed along with the property, that all references affected by the quantifier are non-null.

The exact translation can be seen in table \ref{qfconditionInhale}.

%carbon inhale quantified field. Frame?
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x).f, p(x)) \longmapsto\)\\
\ident Let qpMask be a new Mask\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* assert e(x) is injective */} \\
\ident \textbf{assert\ }\(\forall y_1: T, y_2:T ::\{\}\ y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{\underline{e}(x)\}\ \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:\textit{Ref} ::\{e^{-1}(r)\}\ \underline{c}(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* all receiver is non-null */} \\
\ident \textbf{assume } \( \forall x:T ::\{\}\ \underline{c}(x)  \Rightarrow \underline{e}(x)) != null \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:\textit{Ref} :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\ \{e^{-1}(r)\}\) \\
\ident  \ident \ident \ident \ident \(\underline{c}(e(r)) \Rightarrow\) qpMask\((r, f) = \)Mask\((r.f) + p(e^{-1}(r))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:\)\textit{Ref}\( :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\{ e^{-1}(r)\}\)\\
\ident  \ident \ident \ident \ident \( \ \neg \underline{c}(e^{-1}(r)) \Rightarrow\) qpMask\((r, f) = \) Mask\((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:\)\textit{Object}\(, f_o:\)\textit{Field}\( :: \{\)Mask\((o, f) \}\ \{\)qpMask\((o, f)\}\) \\
\ident  \ident \ident \ident \ident \((f_o != f) \Rightarrow\) qpMask\((o , f) = \) Mask\((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\\ \hline
\caption[carbon quantified field inhale]
   {Translating quantified field inhale operation. The triggers are for the given forall expressions are included within curly brackets. For the expressions assuming non-null receivers and injectivity, there were no triggers defined. In our adaption of this approach, we included triggers for both assumptions. The updated translation can be seen in in Figure \ref{qfconditionInhaleExtended}.}
\label{qfconditionInhale}
\end{longtable}

\paragraph{Exhaling a Quantified Field Permission: }
Exhaling a quantified field permission \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\), includes two checks. First, we assert that the expression \(e(x)\) is injective. Then, we check that we possess the permission needed for exhaling the permission for all locations. If both checks pass, we introduce the inverse function and express the permissions of the map analogous for inhaling a quantified field permission. 
The translation is displayed in table \ref{qfconditionExhale}.

%carbon exhale quantified field
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{exhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x), p(x)) \longmapsto \) \\
\ident Let qpMask be a new Mask   \\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* assert e(x) is injective */} \\
\ident \textbf{assert\ }\(\forall y_1: T, y_2:T ::\{\}\ y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* sufficient permission */} \\
\ident \textbf{assert\ } \(\forall x:T ::\{\}\ c(x) \Rightarrow \)Mask\((e(x), f) \geq \underline{p}(x)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{\underline{e}(x)\}\ \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:\textit{Ref} ::\{e^{-1}(r)\}\ \underline{c}(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:\textit{Ref} :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\ \{e^{-1}(r)\}\) \\
\ident  \ident \ident \ident \ident \(\underline{c}(e(r)) \Rightarrow\) qpMask\((r, f) = \)Mask\((r.f) - p(e^{-1}(r))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:\)\textit{Ref}\( :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\{ e^{-1}(r)\}\)\\
\ident  \ident \ident \ident \ident \( \ \neg \underline{c}(e^{-1}(r)) \Rightarrow\) qpMask\((r, f) = \) Mask\((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:\)\textit{Object}\(, f_o:\)\textit{Field}\( :: \{\)Mask\((o, f) \}\ \{\)qpMask\((o, f)\}\) \\
\ident  \ident \ident \ident \ident \((f_o != f) \Rightarrow\) qpMask\((o , f) = \) Mask\((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\\ \hline
\caption[carbon quantified field exhale]
   {Translating quantified field exhale operation. The missing triggers indicated by empty braces are added in the adapted translation, which is defined in Table \ref{qfconditionExhaleExtended}.}
\label{qfconditionExhale}
\end{longtable}

\subsubsection{Symbolic Execution Rules for Quantified Field Permissions}
\label{seqfp}
A solution to supporting quantified field permissions in symbolic execution is presented in  \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. The approach presented introduces a new type of heap chunk, new rules for inhaling and exhaling single and quantified field permissions, as well as for reading and writing to these field values.

%Quantified Field Chunk
\paragraph{Quantified Field Chunk:}
The permission amount and value of a unquantified field is stored in the heap as a field chunk. A field chunk \((r.f) \mapsto [v, p]\) is a defined for a symbolic reference \(r\) and a field \(f\), which is mapped to the location value \(v\) and the permission amount \(p\). The value \(v\) has the same type as the field \(f\), whereas \(p\) is a permission. 

To support quantified field chunks, a new type of chunk needed to be defined, which can hold a potentially unbounded set of references and values. A straightforward implementation of the expression \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) would result in an heap chunk of the form  \((x, f) \mapsto [v(x), c(x) ? p(x) : 0)]\), where x is of type T. The new chunk is defined for all values of type T. The permission and value depend on x. The value \(v\) is changed to a value map storing the known values of the set. In order to evaluate the permission or value of a location \(r.f\), we would be forced to check for each chunk, whether there exists an \(x\), where \(e(x)\) evaluates to the reference \(r\).

To avoid such existential queries, the representation is adapted to the form \((r.f) \mapsto [v(r), p(r)]\), where \(r\) is of type Ref. To translate the initial permission expression to that form, we again define an inverse function, which maps a location reference to the value of the corresponding quantifier variable of Type T. The resulting quantified field chunk has the form \(r.f \mapsto [v(r), c(e^{-1}(r)) ? p(e^{-1}(r)) : 0)]\). %The domain of a quantified chunk is the set of fields r', where p(r' > 0). 

To guarantee the existence of an inverse function, it is necessary that the expression \(e(x)\) must be injective. This does not restrict the data structures that can be handled by this approach as long as correctly specified.\cite{isc}

%Inhale
\paragraph{Quantified Inhaling:}
%Given a symbolic heap, a path condition and a quantified field permission, inhaling returns an updated heap and path conditions.
Inhaling a quantified field expression generates a new quantified heap chunk. In order to do that, we first evaluate the condition, receiver expression and permission expression. As a next step we introduce the inverse function of the expression \(e(x)\), which is only partially defined for the values where the given condition \(c(x)\) applies. The inverse function is defined by adding two conditions to the path conditions. As a last step, we generate the new quantified heap chunk using the previously defined inverse function  and add it to the heap. As for inhaling a field permission, the value of the field location is initially unknown. The value map, storing the values of the references included in the quantified field chunk, is initially empty.

The symbolic execution rules are presented in Table \ref{qfInhale}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c(y)) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{e}(y)) := eval(h_0, \pi_1 \cup \{\underline{c}(y)\}, e(y)) \)\\
\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_2, p(y)) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \textit{Ref}\(\Rightarrow T\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall r: \)\textit{Ref}\(\cdot \underline{c}(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Inhaling a Quantified Field Permission]
   {These symbolic execution rules for inhaling a quantified field permission correspond to the rules defined in Figure 2 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. The function \textbf{eval} is used to evaluate an expression in the given symbolic state. An evaluation may update the path variables, and yields the resulting symbolic expression. The symbolic value of the evaluated condition is added temporarily to the path condition for the evaluation of e(y) and p(y).}
\label{qfInhale}
\end{longtable}

%Exhale
\paragraph{Quantified Exhaling:}
Exhaling again starts by evaluating the condition, receiver expression and permission expression. As seen for verification condition generation, we check the injectivity of the receiver expression. Afterwards, we introduce the inverse function as before and proceed to remove the permission from the heap.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident \textit{/* Evaluate Arguments (as above) */}\\
\ident [\dots] \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check}\ \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land \underline{e}(y_1) = \underline{e}(y_2) \Rightarrow  y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above) */}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var\ } h_1 := \) \textit{remove} \((h_0, \pi_6, f, (\lambda r \cdot \underline{c}(e^{-1}(r))\ ?\ \underline{p}(e^{-1}(r)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Quantified Field Permission]
   {These symbolic execution rules for exhaling a quantified field permission correspond to the rules defined in Figure 2 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. The \textbf{check} instruction is translated to a query, which is sent to the SMT solver for verification. The function \textit{remove} is defined in Table \ref{qfRemove}.}
\label{qfExhale}
\end{longtable}

Removing the permission will raise an error, if not enough permission is held. Otherwise the function will return the updated heap. Since we create a new quantified field chunk for every inhale, the permission required may be held in multiple chunks simultaneously. When removing a certain permission amount, we first filter all quantified chunks with the required field \(f\). 
We proceed to remove permissions greedily until we removed the required permission amount. Subtracting the permission for a specific chunk is expressed by defining introducing a function \(q_{current}\). After updating the permission for all quantified field chunks of field \(f\), we check that sufficient permission was taken and return the updated heap.
The symbolic execution rules for the function \textit{remove} are displayed in Table \ref{qfRemove}.

%remove
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, q) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all chunks in given state for field \(f\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_f := \emptyset \) \\
\ident \textit{/* Permission still to take */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(r.f  \mapsto [v_i(r), q_i(r)] \in h_f\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda r \cdot min(q_i(r), q_{needed}(r))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda r\cdot q_{needed}(r) - q_{current}(r)) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_f := h'_f \cup \{r.f \mapsto [v_i(r), (q_i(r) - q_{current}(r))] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check}\ \pi_0 \models \forall r \cdot q_{needed}(r) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_f)  \cup h'_f \) \\
\}\\ \hline
\caption[Remove a Field Permission]
   {These symbolic execution rules for removing permission of a quantified field expression correspond to the rules defined in Figure 3 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. The argument \(f\) represents a field, \(q\) contains the permission amount needed per reference.}
\label{qfRemove}
\end{longtable}

\paragraph{Inhale Field Permission:}
In order to use the remove function defined, we need to adapt the approach for inhaling and exhaling unquantified field permissions. In Silicon, inhaling a single field permission is only adapted if the field is ever used in a quantified field permission. In that case, inhaling a field permission produces a quantified field permission as well. To express the field permission \(acc(e.f, p)\)  as its equivalent quantified chunk, we define its permission as \(p\) if  the reference is equal to the location specified by the expression \(e\). The updated inhaling rules are presented in Table \ref{sqfInhale}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  acc(e.f, p)\) \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1,\underline{e}) := eval(h_0, \pi_0, e)) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{p}) := eval(h_0, \pi_1, p) \)\\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \}   (r = \underline{e})\ ?\ \underline{p} : 0]\) \\
\ident \textbf{return} \( (h_1, \pi_2) \) \\
\}\\ \hline
\caption[Inhaling a single Quantified Field Permission]
   {The symbolic execution rules for inhaling a field permission, where the field is quantified at some point during the program, is adapted in order to represent all permission to a quantified field as quantified chunks.}
\label{sqfInhale}
\end{longtable}

\paragraph{Exhale Field Permission:}
Exhaling a single field permission \(acc(e.f, p)\) is handled similarly. If a field is quantified, we reuse the function remove, defining the required permission as \(p\) if the location is equal to \(e.f\) and 0 otherwise. The updated exhaling rules are presented in Table \ref{sqfExhale}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  acc(e.f, p)\) \{\\
\ident \textit{/* Evaluate Arguments (as above) */}\\
\ident [\dots] \\
\\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var\ } h_1 := \) \textit{ remove}\((h_0, \pi_2, f, (\lambda r \cdot (r = \underline{e})\ ?\ \underline{p} : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Field Permission]
   {Analogous for inhaling a field permission, the symbolic execution rules for exhaling a field permission are adapted, if the field is quantified at some point during the program.}
\label{sqfExhale}
\end{longtable}

\paragraph{Evaluation}
The value information of a quantified field chunk is stored in its value map \(v\). It represents a under-specified total function and is defined per reference. A symbolic heap may consist of multiple chunks for the same field. To provide a simple translation for field-lookups, the function summarise was introduced. Given a field \(f\), it generates a value map, containing the values for all references defined, as well as the permission expressions held per location. Summarise only works with the defined heap chunks and does not consider path conditions. The symbolic execution rules are defined in Table \ref{qfSum}.

\begin{longtable}{| p{1\textwidth} | }
\hline
\textbf{summarise}\(\ (h_0, f) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for field \(f\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \textit{def} \(:= \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \textit{perm} \(:= \lambda r \cdot 0\) \\
\ident \textbf{foreach } \((r.f \mapsto [v_i(r), q_i(r)]) \in h_f \) \textbf{do:} \\
\ident \ident \(\mathit{def} := \mathit{def}  \cup \{ \forall r \cdot 0 < q_i(r)  \Rightarrow v(r) = v_i(r) \} \) \\
\ident \ident \(\mathit{perm} := \lambda r \cdot (\mathit{perm}(r) + q_i(r)) \) \\
\ident \textbf{return } \((v,\mathit{def}, \mathit{perm})\) \\
\}\\ \hline
\caption[Summarise Quantified Field Permissions]
   {These symbolic execution rules for summarising quantified field permissions correspond to Figure 5 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. It introduces a fresh value map and walks through all quantified field chunks of field \(f\), summarising the values for the defined locations and the permission for all references.}
\label{qfSum}
\end{longtable}

If we evaluate the value of a single field location \(e.f\), we first evaluate the location and summarise all heap chunks of field \(f\). After checking we hold sufficient permission, we read the value from the generated value function. The symbolic execution rules are presented in Table \ref{qfEval}.

\begin{longtable}{| p{1\textwidth} | }
\hline
\textbf{eval}\(\ (h_0, \pi_0, e.f) \) \{\\
\ident \textbf{var } \((\pi_1, \underline{e}) :=\) \textbf{eval} (\(h_0, \pi_0, e)\) \\
\ident \textbf{var } \((v, \) \textit{def}\(,\) \textit{perm}\() :=\) \textbf{summarise} (\(h_0, f)\) \\
\ident \textbf{check } \(\pi_1 \models 0 < perm(\underline{e}) \) \\
\ident \textbf{return } \(\pi_1 \cup\) \textit{def}\(, v(\underline{e})\) \\
\}\\ 
\hline
\caption[Evaluate Field Permission]
   {These symbolic execution rules evaluating the value of a field permissions correspond to Figure 6 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution} \cite{isc}. It calls the function summarise and uses the looks up the value of the given location in the returned value map.}
\label{qfEval}
\end{longtable}

\paragraph{Field Write}
A field write \(e_1.f := e_2\) is desugared into exhaling and then inhaling the access permission of the field \(e_1.f\), followed by inhaling the equality of \(e_1.f\) and \(e_2\). Exhaling the permission of the field checks whether we possess sufficient permission to write to the field. The rules are presented in Table \ref{qfWrite}.

\begin{longtable}{| p{1\textwidth} | }
\hline
\textbf{execute}\(\ (h_0, \pi_0,e_1.f := e_2) \) \{\\
\ident \textbf{exhale } \(acc(e_1.f)\) \\
\ident \textbf{inhale } \(acc(e_1.f)\) \\
\ident \textbf{inhale } \( e_1.f == e_2\) \\
\}\\ 
\hline
\caption[Evaluate Field Permission]
   {These symbolic execution rules for desugaring a field write for a quantified field.}
\label{qfWrite}
\end{longtable}

\section{Generalising Quantified Field Permissions in Carbon}
\label{genField}
The approach presented in section \ref{cgqf} did not include any triggers for some expressions. In such a case, triggers are generated by the underlying tools. To make the behavior of quantified expressions more reliable and to possibly reduce unnecessary invocations, we introduced triggers for these expressions. 

The non-null assumption should be triggered for all locations. It would therefore be a possibility to reformulate the assumption as a quantifier over all references. It is however sufficient to use the same trigger as the first inverse assumption, namely \(e(x)\), since this expression will be triggered via the second inverse function when accessing a field location. An injectivity assertion on the other hand, doesn't need to be be triggered. For that purpose, we introduce a new function \textit{triggerFun}, which takes the quantifier variable as an argument.

As another extension, we added the support for user-given triggers on quantified permissions, which were previously not supported. Most generated expressions should trigger independently of that trigger. For example, it is unnecessary to add a user-given trigger to the expression defining the permissions of the map \textit{Mask}, since the user cannot define a more general trigger than \textit{Mask}\((o , f)\)  and \(qpMask\)\((o , f) \). Other triggers are necessary to ensure the desired behavior of quantified permissions. The most obvious example would be the trigger for the second inverse assumption, which has to be triggered for each invocation of the inverse function. Instead of replacing the previously generated triggers, we add a user-given trigger to certain expressions. A user-given trigger without alterations can only be added to expression with the same quantifier variable type as the original quantifier. Since all other quantified assumption are already triggered by the inverse function, there is no advantage in adding a modified trigger in these cases. We add the user-given function to the first inverse assumption as well as the non-null assumption and check for sufficient permission.

If no user-given trigger is defined, we reuse the trigger-generation function provided for pure quantifiers in order to provide additional triggers. This can be helpful in cases where \(e(x)\) does not constitute a valid trigger. Since Carbon does not support nested quantifiers, the generation of triggers was adapted to not define additional variables. The adapted triggers are displayed in Table \ref{qfconditionInhaleExtended} and \ref{qfconditionExhaleExtended}.

%carbon inhale quantified field. Frame?
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x).f, p(x)) \longmapsto\)\\
\ident Let qpMask be a new Mask\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* assert e(x) is injective */} \\
\ident \textbf{assert\ }\(\forall y_1: T, y_2:T ::\{\mathit{triggerFun}(y_1), \mathit{triggerFun}(y_2)\}\ y_1  \ne y_2 \land \) \\
\ident \ident \ident \ident \ident \(\underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{\underline{e}(x)\} \{trs\}\ \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:\textit{Ref} ::\{e^{-1}(r)\}\ \underline{c}(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* all receiver is non-null */} \\
\ident \textbf{assume } \( \forall x:T ::\{\underline{e}(x)\} \{trs\} \underline{c}(x)  \Rightarrow \underline{e}(x)) != null \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:\textit{Ref} :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\ \{e^{-1}(r)\}\) \\
\ident  \ident \ident \ident \ident \(\underline{c}(e(r)) \Rightarrow\) qpMask\((r, f) = \)Mask\((r.f) + p(e^{-1}(r))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:\)\textit{Ref}\( :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\{ e^{-1}(r)\}\)\\
\ident  \ident \ident \ident \ident \( \ \neg \underline{c}(e^{-1}(r)) \Rightarrow\) qpMask\((r, f) = \) Mask\((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:\)\textit{Object}\(, f_o:\)\textit{Field}\( :: \{\)Mask\((o, f) \}\ \{\)qpMask\((o, f)\}\) \\
\ident  \ident \ident \ident \ident \((f_o != f) \Rightarrow\) qpMask\((o , f) = \) Mask\((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\hline
\caption[carbon quantified field inhale]
   {The expressions generated during a quantified inhale are adapted for the first inverse function assumption, as well as the non-null assumption. Both expressions are triggered on the expression denoting the receiver and the user-given or automatically generated triggers. The translation are adapted from Table \ref{qfconditionInhale}.}
\label{qfconditionInhaleExtended}
\end{longtable}

%carbon exhale quantified field
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{exhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x), p(x)) \longmapsto \) \\
\ident Let qpMask be a new Mask   \\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* assert e(x) is injective */} \\
\ident \textbf{assert\ }\(\forall y_1: T, y_2:T ::\{\mathit{triggerFun}(y_1), \mathit{triggerFun}(y_2)\}\ y_1  \ne y_2 \land \) \\
\ident \ident \ident \ident \ident  \(\underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* sufficient permission */} \\
\ident \textbf{assert\ } \(\forall x:T ::\{\underline{e}(x)\} \{trs\}\ c(x) \Rightarrow \)Mask\((e(x), f) \geq \underline{p}(x)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{\underline{e}(x)\} \{trs\} \ \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:\textit{Ref} ::\{e^{-1}(r)\}\ \underline{c}(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:\textit{Ref} :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\ \{e^{-1}(r)\}\) \\
\ident  \ident \ident \ident \ident \(\underline{c}(e(r)) \Rightarrow\) qpMask\((r, f) = \)Mask\((r.f) - p(e^{-1}(r))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:\)\textit{Ref}\( :: \{\)Mask\((r, f)\}\ \{\)qpMask\((r, f)\}\{ e^{-1}(r)\}\)\\
\ident  \ident \ident \ident \ident \( \ \neg \underline{c}(e^{-1}(r)) \Rightarrow\) qpMask\((r, f) = \) Mask\((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:\)\textit{Object}\(, f_o:\)\textit{Field}\( :: \{\)Mask\((o, f) \}\ \{\)qpMask\((o, f)\}\) \\
\ident  \ident \ident \ident \ident \((f_o != f) \Rightarrow\) qpMask\((o , f) = \) Mask\((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\hline
\caption[carbon quantified field exhale]
   {Translating quantified field exhale operation. \(trs\) is a place-holder for the user-defined triggers or if no trigger was given, a set of auto-generated triggers as used for pure quantifiers.The triggers were adapted for both assertions, as well as the first inverse assumptions. The translation is an adaption of Table \ref{qfconditionExhale}.}
\label{qfconditionExhaleExtended}
\end{longtable}

\section{Quantified Predicate Permissions}
\label{qp}
In order to generalise the form of quantified permissions, we lift the restriction on the type of the location. In this section we discuss how the presented solution for quantified field permission has to be adapted in order to support quantified predicate permissions. 
As the general form of a quantified predicate permission we consider the following adaption of the form presented for quantified field permissions: 
\begin{equation}
 \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(pred(e_1 (x),â€¦,e_n (x)), p(x)), 
\end{equation}
where \(c(x)\) is a Boolean expression, \textit{pred} a predicate name, \(\ e_i(x)\) denotes the expression conforming to the type of the ith arguments of the predicate \textit{pred} and \(p(x)\) permission expression. Introducing this new form allows us to express permission to more complex structures such as a set of lists.

To explain the adaption needed for the implementation, we discuss the answers to the following questions \cite{isc}:
\begin{enumerate}
\item How to model the program state, including permissions and values?
\item How to check for a permission in a state?
\item How to add and remove permissions to and from a state?
\item How to evaluate (heap-dependent) expressions in a state?
\item When to preserve (frame) an expression's value across heap changes?
\end{enumerate}
%Example

For Verification Condition Generation, these questions are answered in the following section \ref{vcgPredicate}. For Symbolic Execution, the first problem is handled in section \ref{shr}, the second and third in section \ref{qpInhaleSec} to \ref{pInhaleExhaleSec}. The fourth and fifth questions are answered  in section \ref{qppVals} to \ref{SecFold}.

\subsection{Verification Condition Generation for Quantified Predicate Permissions}
\label{vcgPredicate}
In Carbon, the permission held for a predicate instance is stored in the map \textit{Mask}. The permissions held to a predicate location of the predicate \textit{pred} with n arguments is stored at \textit{Mask}\([null,\) \textit{pred'}\((arg_1, \dots, arg_n)]\), where \textit{pred'} represents a function returning a field locationof the mask for the predicate \textit{pred} with given arguments. Similar to the approach for quantified predicate permissions, we introduce a translation for inhaling and exhaling quantified predicate permissions. There are no adaptions needed for the definition of the program state, nor do we need to change anything concerning the evaluation of  permissions. The implementation of the operations unfold, fold and unfolding does not have to be changed. 

Framing is done as for quantified field permissions by defining a new map, which later replaces the current map. For this map, we define all known permissions. For the locations included within a quantifier, the permission is increased or decreased by the designated amount. For the independent locations the permission remains unchanged. These include all field and magic wand locations, predicate instances of different predicate names, as well as predicate instances not satisfying the quantifier condition.

To translate a quantified predicate permission, we reuse the solution presented for quantified fields. As for quantified field permissions, we evaluate the arguments, introduce an inverse function, assume injectivity and define the updated permissions for the newly created map holding the permissions for predicates. We need, however to redefine the definition of the inverse function and injectivity.

A predicate location is defined by a predicate name and a set of arguments. As before we wish to define the updated locations using a quantified neutral location. Whereas the approach for quantified field permission uses a fix reference \(r\) to find the general location of a field, a neutral predicate depends on a set of arguments. The number of arguments and their type may differ for each predicate. To express the neutral locations, we declare a set of neutral arguments \(arg_1, \dots, arg_n\) for each quantified predicate definition. 

In order to translate the given permission for that location, we need to adapt the definition of the inverse function presented in section \ref{qf}. As before, the inverse function is used to map a general location to the variable used in the original quantified permission expression. A new inverse function is defined for each expression. Since the predicate name is however independent of the quantifier variable, it is not necessary to include it as an argument of the inverse function. The adapted definition of the inverse function is only depending on the arguments themselves.

As before, given the arguments of the predicate, the new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier. The adapted inverse function is defined as:\\

\begin{tabularx}{1\textwidth}{ X}
\textbf{function }\(e^{-1}(a_1:A_1, \dots, a_n:A_n): T\) \\
\(\forall \ x:T :: c(x) \Rightarrow e^{-1}(e_1 (x),â€¦,e_n (x))==x \) \\
\( \forall \ a_1:A_1,\dots, a_n:A_n ::  c(e^{-1}(a_1, â€¦,a_n )) \Rightarrow e_i (e^{-1}(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}\\

The inverse function is, as before, a partial function defined only for values where the condition of the original quantifier applies.

Similar to quantified field permissions, we have to restrict the allowed expression terms as a result to guarantee the existence of the defined inverse function. The location expressed by the quantifier has to be injective.This is guaranteed if at least one argument expression differs for all two values of the quantifier variable. This property can be expressed by the following equation:\\

\begin{tabularx}{1\textwidth}{ X}
 \(\forall x_1:T, x_2: T :: c(x_1) \land c(x_2) \land (e_1(x_1) = e_1(x_2)) \land \dots \land  (e_n(x_1) = e_n(x_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(x_1 = x_2\) \\
\end{tabularx}\\

The adapted translations of inhaling and exhaling quantified predicate permissions are depicted in Table \ref{qpcInhale} and Table \ref{qpcExhale}.

%carbon missing: triggers
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),\dots,e_n (x)), p(x)) \) \{\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \(\underline{e_1} := eval(e_1)\)\\
\ident \([\dots]\) \\
\ident \(\underline{e_n} := eval(e_n)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \textbf{assume } \( \forall x:T :: \{\} \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\ident \textbf{assume\ } \( \forall a_1: A_1, \dots, a_n: A_n :: \{e^{-1}(a_1, \dots, a_n)\} \ c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\\
\ident \textit{/* Injectivity Assumption */} \\
\ident \textbf{assume\ }\(\forall y_1:T, y_2:T\ \{\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \lor  (\underline{e_n}(y_1) \ne \underline{e_n}(y_2))\) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{qpMask[null, pred(a_1, \dots, a_n)\}\) \\
\(\{Mask[null, pred(a_1, \dots, a_n)\}\{e^{-1}(a_1, \dots, a_n)\} \ c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)]  +  p(inv(a_1, \dots, a_n))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\}\ \neg c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)] \)\\
\ident \textbf{assume\ } \(\forall o:Ref, f:Field :: \{qpMask[o, f]\} \{Mask[o, f]\}\ (obj \ne null \land \neg isPredicateField(f) \land predicateId(f) != predicateId(pred)) \Rightarrow perm(o.f , a_n)) = \) \textbf{old} \((perm(o.f)) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon quantified predicate inhale]
   {Translation of inhaling a quantified predicate permission. The corresponding translation for quantified field permissions is displayed in Table \ref{qfconditionInhale}. The translation differs in the definition of the general location, the inverse function and the injectivity assumption. Additionally, there is no need for a non-null assumptions for predicates. The independent locations include all instances not satisfying the condition \(c(x)\), as well as  all mask entries not pointing to a predicate instance of \(pred\). To distinguish predicates by the predicate name, we introduce the function \textit{predicateId}, which is unique for each predicate name and generated when translating a predicate declaration.}
\label{qpcInhale}
\end{longtable}

%carbon exhale quantified field
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),\dots,e_n (x)), p(x)) \) \{\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \(\underline{e_1} := eval(e_1)\)\\
\ident \([\dots]\) \\
\ident \(\underline{e_n} := eval(e_n)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* Injectivity Assumption */} \\
\ident \textbf{assume\ }\(\forall y_1:T, y_2:T\ \{\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \lor  (\underline{e_n}(y_1) \ne \underline{e_n}(y_2))\) \\
\\
\ident \textit{/* sufficient permission assertion*/} \\
\ident \textbf{assume\ } \(\forall x:T :: \{\} c(x) \Rightarrow Mask[null, pred(\underline{e_1}(x), \dots, \underline{e_n}(x))]  \geq \underline{p}(x)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \textbf{assume } \( \forall x:T :: \{\} \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\ident \textbf{assume\ } \( \forall a_1: A_1, \dots, a_n: A_n :: \{e^{-1}(a_1, \dots, a_n)\} \ c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{qpMask[null, pred(a_1, \dots, a_n)\}\) \\
\(\{Mask[null, pred(a_1, \dots, a_n)\}\{e^{-1}(a_1, \dots, a_n)\} \ c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] \) \\
\( == Mask[null, pred(a_1, \dots, a_n)]  -  p(inv(a_1, \dots, a_n))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\}\ \neg c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)] \)\\
\ident \textbf{assume\ } \(\forall o:Ref, f:Field :: \{qpMask[o, f]\} \{Mask[o, f]\}\ (obj \ne null \land \neg isPredicateField(f) \land predicateId(f) != predicateId(pred)) \Rightarrow perm(o.f , a_n)) = \) \textbf{old} \((perm(o.f)) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon quantified predicate exhale]
   {Translation of exhaling a quantified predicate permission.The corresponding translation for quantified field permissions is displayed in Table \ref{qfconditionExhale}. The translation differs in the definition of the injectivity check, the general location and the inverse function.}
\label{qpcExhale}
\end{longtable}

\subsection{Symbolic Execution}
In this section, we adapt the solution for quantified field permissions described in section \ref{seqfp} to support quantified predicate permissions for symbolic execution.

\subsubsection{Symbolic Heap Representation} \label{shr}
In order to reason about quantified predicate permissions, it is necessary to define a symbolic heap representation for a potentially unbound set of predicate instance of the same predicate simultaneously. In the previous design, a quantified field chunk is defined by the field name, where permission and value are defined using a general location reference \(r\).
For quantified predicate chunks we use the predicate name instead of the field as identification and express the permission and value definition by defining a set of general arguments. The general form of such a heap chunk conforms to:
\begin{equation}
	\mathbf{pred}(\mathrm{arg_1, ..., arg_n})\mapsto [v(\mathrm{arg_1, ..., arg_n}), p(\mathrm{arg_1, ..., arg_n}))],
\end{equation}
where \textit{v} represents a value map, where a value represent the snapshot of that predicate instantiation.
Given the new definition of quantified predicate heap chunks, we define the \(inhale\) and \(exhale\) operations for quantified predicate permissions.

\subsubsection{Quantified Inhaling} 
\label{qpInhaleSec}
The adapted symbolic execution rules for a inhaling a quantified permission can be seen in Figure \ref{qpInhale}. It differs in the definition of the inverse function, as well as the values of the value map.

As before, inhaling a quantified predicate permission updates a given state and returns an updated heap and path condition. Similarly the quantified field expression, the condition, argument expressions and permission expression are evaluated as a first step.

The inverse function is introduced analogous to a quantified field permission and further defined by adding two constraints to the path condition, defining its properties. The the cardinality of the inverse function may vary for different predicates, but is identical for the same predicate.

As a last step we introduce a value map, which is later used to keep track of the snapshot of predicate instantiations. These values are used during an unfold or unfolding.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \)  \textbf{forall } \(x:T :: c(x) \Rightarrow \)  \textbf{acc} (\textit{pred}  \( (e_1 (x),â€¦,e_n (x)), p(x)) \)  \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}(y)) := eval(h_0, \pi_{2_{n-1}}, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident \textit{/* Introduce value map */}\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Inhaling a Quantified Predicate Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission. They refer to the rules for inhaling quantified field permissions of Figure \ref{qfInhale}. The declaration of the inverse function is updated as described before. The inverse function takes a set of predicate arguments and returns the value of the variable originally expressed in the quantifier. The type of the value map corresponds to the snapshot type of the predicate.}
\label{qpInhale}
\end{longtable}

\subsubsection{Quantified Exhaling} 
\label{qpExhaleSec}
The adaptations necessary for exhaling quantified predicate permissions again include an update for evaluating the argument expressions, as well as the introduction of the inverse function as defined for inhaling. Additionally, the injectivity check needs to be adapted as defined in the previous section. The new rules are defined in Table \ref{qpExhale}.

After evaluating the expressions denoted by the quantified predicate permission, we check the injectivity before introducing the inverse functions as defined in the inhaling. The check passes if for any two variables satisfying the initial condition,  at least one argument expression is evaluated to a different symbolic value.

The definition of removing permission from a quantified predicate is adapted as well. It filters quantified chunks to include only the chunks with the given predicate name. We again iterate through these chunks, taking permission greedily and check whether enough permission was taken as a final step. The definition of \(q_{needed}\) and \(q_{current}\) is adapted to take a set of predicate arguments. The updated definition for the function remove can be seen in Table \ref{qpRemove}.

%exhale
\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),â€¦,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Quantified Predicate Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission. The corresponding rules for quantified field permission is displayed in Table \ref{qfExhale}. The changes include the updated definition of the injectivity check, inverse function and general predicate location.} %expand description: check, remove....
\label{qpExhale}
\end{longtable}

%remove
\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{remove}\(\ (h_0, \pi_0, pred, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - \) \\ 
\ident \ident \( q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\caption[Remove a Quantified Predicate Permission]
   {Symbolic execution rules for removing a quantified predicate permission. The corresponding rules for quantified field permission is displayed in Table \ref{qfRemove}. The changes include the updated filtering of chunks by the predicate name, as well the cardinality of the input parameter of \(q_{current}\) and \(q_{needed}\), which are used to define the amount of permission subtracted per chunk.}
\label{qpRemove}
\end{longtable}

\subsubsection{Inhaling and Exhaling Single Predicate Permission} 
\label{pInhaleExhaleSec}
In order to use the remove function defined, we again need to adapt the approach for inhaling and exhaling single predicate permissions. When inhaling, we define a quantified predicate chunk, where the permission is defined only if all arguments are identically to the input arguments. When exhaling a predicate permission, we define the needed permission the same way. Analogous for the implementation of quantified fields, silicon only adapts the inhaling and exhaling of single predicates, if the predicate is quantified at some point in the given program.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  acc(pred(a_1, \dots, a_n), p)\) \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_{1},\underline{e_1}(y)) := eval(h_0, \pi_0 \cup \{ \) \underline{c}\( (y)\}, e_{1})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{n},\underline{e_n}(y)) := eval(h_0, \pi_{n-1}, e_{n})) \)\\
\ident \( \mathbf{var\ } (\pi_{n+1},\underline{p}) := eval(h_0, \pi_n, p) \)\\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), ((a_1 == \underline{e}_1) \ \&\&\ \dots \ \&\&\ (a_n == \underline{e}_n)) ? \ \underline{p} : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_{n+1}) \) \\
\}\\ \hline
\caption[Inhaling a single Quantified Field Permission]
   {The symbolic execution rules for inhaling a predicate permission, where the predicate is quantified at some point during the program, is adapted in order to represent all permission to the quantified predicate in quantified chunks. These rules correspond to the rules displayed for quantified field permission in Table \ref{sqfInhale}. The definition of the quantified predicate chunk generated is adapted to consider all arguments of the predicate.}
\label{sqpInhale}
\end{longtable}

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  acc(e.f, p)\) \{\\
\ident \textit{/* Evaluate Arguments (as above) */}\\
\ident [\dots] \\
\\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var\ } h_1 :=  remove(h_0, \pi_{n+1}, f, (\lambda a_1, \dots, a_n \cdot ((a_1 == \underline{e}_1) \ \&\&\ \dots \ \&\&\ (a_n == \underline{e}_n))\ ?\ \underline{p} : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_{n+1}) \) \\
\}\\ \hline
\caption[Exhaling a Field Permission]
   {Analogous for inhaling a predicate permission, the symbolic execution rules for exhaling a predicate permission are adapted, if the predicate is quantified at some point during the program. These rules correspond to the rules displayed for quantified field permission in Table \ref{sqfExhale}. The definition of the permission required is adapted to consider all arguments of the predicate.}
\label{sqpExhale}
\end{longtable}

\subsubsection{Treatment of Symbolic Values} 
\label{qppVals}
Predicates may modify symbolic values while unfolding and folding predicates. When working with quantified predicates, the unfold and fold operations need to be adapted. Unfolding a predicate can be desugared as before. As for exhaling and inhaling single predicates, the functions fold and unfold only need to be adapted for predicates which are quantified at some point during the program.

In order to summarise the values and permission of a single predicate, we adapt the summarise function presented for quantified field permission. The function walks through all quantified chunks of the given predicate, keeping track of the values and permissions held for all locations. The symbolic execution rules are displayed in Table \ref{qpSum}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{summarise}\(\ (h_0, pred) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for predicate \(pred\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \(def := \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \(perm := \lambda r \cdot 0\) \\
\ident \textbf{foreach } \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:}\\
\ident \ident \(def := def \cup \{ \forall a_1, \dots, a_n \cdot 0 < q_i(a_1, \dots, a_n)  \Rightarrow v(a_1, \dots, a_n) = v_i(a_1, \dots, a_n) \} \) \\
\ident \ident \(perm := \lambda a_1, \dots, a_n \cdots (perm(a_1, \dots, a_n) + q_i(a_1, \dots, a_n)) \) \\
\ident \textbf{return} \((v, def, perm)\) \\
\}\\ \hline
\caption[Summarise Quantified Field Permissions]
   {Symbolic execution rules for summarsing quantified predicate permissions. The function is adapted from the summarise function for quantified field permission depicted in Table \ref{qfSum}}
\label{qpSum}
\end{longtable}

\subsubsection{Unfold} 
\label{qUnfold}
When unfolding a quantified predicate, we first evaluate the arguments of the predicate and summarise the quantified predicate chunks in order to evaluate the predicate's snapshot. As a next step, we relinquish the permission for the predicate instance by exhaling write permission to the predicate instance, followed by inhaling the snapshot, which is a representation of the body of the predicate. The symbolic execution rules for the unfold operation are displayed in Table \ref{qUnfold}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{unfold}\(\ (h_0, \pi_0, pred(e_1, \dots, e_n))\) \{\\
\ident \textit{/* evaluate arguments */} \\
\ident \( \mathbf{var\ } (\pi_{1},\underline{e_1}) := eval(h_0, \pi_0, e_1)) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{n},\underline{e_n}) := eval(h_0, \pi_0, e_n)) \)\\
\\
\ident \textit{/* read the predicate's snap value */} \\
\ident \textbf{var } \((v, \) \textit{def}, \textit{perm}\() :=\) \textit{summarise} \((h_0, pred)\) \\
\ident \textbf{var } snapshot \(:=\) \( v (\underline{e_1}, \dots, \underline{e_n})\)\\
\\
\ident \textbf{var } \((h_1, \pi_{n+1}) :=\) exhale\((h_0, \pi_n \cup def, pred(e_1, \dots, e_n))\) \\
\ident \textbf{var } \((h_2, \pi_{n+2}) :=\) inhale\((h_1, \pi_{n+1}, snapshot)\) \\
\ident \textbf{return} \( (h_2, \pi_{n+2}) \)  \\
\}\\ \hline
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for the unfold operation. The function summarise refers to the function declared in Table \ref{qpSum}. Inhaling the snapshot of the predicate is equal to inhaling the predicate body for the values denoted by the snapshot.}
\label{qUnfold}
\end{longtable}

%overview
\subsubsection{Fold} 
\label{SecFold}
As mentioned in the background, folding a predicate exchanges the permission of the body with the permission to the predicate which is being folded. It creates a new quantified predicate chunk. The predicate chunk contains the values of the permissions held by the predicate body previous to folding it, which is called a snapshot of the predicate.

When folding a quantified predicate, we first generate a snapshot based on the current heap. Exhaling the snapshot is equivalent to exhaling the body of the predicate, where the values the body relies on are revealed in the snapshot. Exhaling the snapshot is checking that enough permission is held to fold the predicate. After exhaling the predicate body, we generate a new quantified predicate chunk, where the value map is defined for the given predicate and maps to the generated snapshot.

The symbolic execution rules for the operation fold can be seen in Figure \ref{qFold}.
%fold
\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{fold}\(\ (h_0, \pi_0, pred(e_1, \dots, e_n))\) \{\\
\ident \textit{/* evaluate arguments */} \\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}) := eval(h_0, \pi_0, e_1)) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}) := eval(h_0, \pi_0, e_n)) \)\\
\\
\ident \textit{/* generating the predicate's snap value */} \\
\ident \textbf{var } snapshot \(:=\) \textit{generateSnap}\((h_0, pred, (\underline{e_1}, \dots, \underline{e_n}))\)\\
\\
\ident \textbf{var } \((h_1, \pi_{n+1}) :=\) exhale\((h_0, \pi_n, snapshot) \) \\
\ident Let  \(v\)  be a fresh value map \\
\ident \(v(\underline{e}_1, \dots, \underline{e}_n) = snapshot\)\\
\ident \( \mathbf{var\ } h_2 :=  h_1 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), ((a_1 == \underline{e}_1) \ \&\&\ \dots \ \&\&\ (a_n == \underline{e}_n)) ? \ 1 : 0] \}  \) \\
\ident \textbf{return} \( (h_2, \pi_{n+2}) \)  \\
\}\\ \hline
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for folding a quantified predicate. This adaption is only needed for predicates, which are quantified at some point in the given program. It exhales the predicate body and generates a new quantified chunk which holds the snapshot generated before exhaling the body.}
\label{qFold}
\end{longtable}

%silicon

\subsection{Implementation}
We implemented both approaches presented. The approach for verification condition generation is implemented in Carbon and does not differ from the approach.

The approach for symbolic execution is implemented in Silicon. There are a few subtle differences between the approach and the implementation. As for quantified field permission, Silicon analyses the program given, creating a list of quantified predicates. Additionally, it also precomputes a set of predicate arguments used to express the general predicate locations in quantified heap chunks and assertions generated, as well as a general snapshot. The predicate arguments added to the state.
Exhaling a single predicate instance provides the snapshot of that predicate. Removing a certain permission amount is implemented - as for quantified field permissions - as a combination of the presented functions remove and summarise. This is straightforward, since both iterate through the quantified predicate chunks filtered by the predicate name.

\subsubsection{Issues}
Triggering Sequences

Quantified unfolding

%Quantified Magic Wands
\section{Quantified Magic Wands}
\label{qmw}
As mentioned in chapter , a magic wand is represented using its footprint. A footprint may consist of multiple arguments. As a consequence, the definition for the inverse function and the injectivity test is defined analgous to quantified predicate permissions.

In verification condition generation, a magic wand instance is represented in the form wand\( (f_1, \dots, f_n) \), where \(f_i\) represents the ith argument of the magic wand's footprint. The definitions for inhaling and exhaling a quantified magic wand is done exaclty as in Figure \ref{qpcInhale} and \ref{qpcExhale}, where the predicate name is replaced with wand, and the argument expressions correspond to the footprints.
Again, there is no need to adapt the implementations of \textit{apply} and \textit{package}.

As for symblolic execution rules, the same principle applies.%Go on?

%Combinations of Quantifiers
\section{Combinations of Quantifiers}
\label{rewriting}
Viper currently does not allow merging pure and permission-based quantifiers, nor does it allow combinations of multiple quantified permissions. This can be circumvented by repeating the definitions prior to the quantified expression.
To decrease the code size for specifying the properties desired and support user-friendliness, we present a solution to lift this restriction.

We extend the support of quantifiers to include the following expressions:
\begin{longtable}{ p{1\textwidth} } 
\textbf{forall} \(x:T :: \{trs\}\  Exp\),\\
\ident \( Exp := b\)  \\
\ident \ident \(|\ acc(e.f, p)\) \\
\ident \ident \(|\ acc(P(arg_1, \dots, arg_n), p)\) \\
\ident \ident \(|\ A \wand B\) \\
\ident \ident \(|\ Exp_1 \ \&\&\ Exp_2\) \\
\ident \ident \(|\ b \Rightarrow Exp\), \\
\label{combinations}
\end{longtable}
where {\it trs} is an optional set of triggers and \(b\) a pure expression. The last two expressions allow us to combine quantified expressions of various types. For example, the following expression  is allowed: 
\begin{longtable}{ p{1\textwidth} } 
\textbf{forall} \(x:T :: x\ in\ xs \Rightarrow (i > 0 \Rightarrow (acc(x.f) \ \&\&\ x.f  = i)) \ \&\&\ (i <= 0 \Rightarrow acc(P(x))) \) \\
\end{longtable}

Other combinations of quantified expressions, such as \(acc(x.f) \Rightarrow (x.f == i)\) or \(acc(x.f) || acc(x.g)\),  are not included, since they are not permitted for the unquantified expressions. Combinations of pure quantifiers are already supported in Viper, as are quantified fields. The approaches for quantified predicates and magic wands are treated using the ones defined previously.

Besides allowing combinations of quantifiers, we also lift the restriction of having to define a condition in a permission-based quantifier. If no condition is defined, the forall expression is rewritten to the following form:
\begin{longtable}{ p{1\textwidth} } 
\textbf{forall} \(x:T :: true \Rightarrow Exp\) \\
\end{longtable}

For some cases this is, however, undesirable. If \(x\) is of type \textit{Ref}, Carbon includes the null reference in the set of all references, which leads to an inconsistent state when inhaling the access rights to all references due to the non-null assumption.

In order to support the combinations defined above, we add two rewriting rules explained in the following sections. In order to illustrate some of the challenges supporting these new expressions, we discuss the following example:
\begin{longtable}{ p{1\textwidth} } 
inhale \textbf{forall} \(x:Ref :: (x\ in\ xs \Rightarrow (acc(x.f) \ \&\&\ x.f  = i)) \ \&\&\ (x\ in\ ys \Rightarrow acc(P(x))) \) \\
\end{longtable}

If a reference \(x\) is within the set of references \(xs\), we inhale the access to the field location defined by that reference and gain the information that its value is equal to \(i\). If a reference is within the set \(ys\), we gain the access right to the predicate \(P(x)\). Please note, that we cannot assume the value of a field without holding partial permissions. The sub-expressions of the combinations may depend on each other, which enforces that \(acc(x.f)\) needs to be inhaled before accessing the field \(x.f\).

When combining two quantifiers, the expressions may depend on the fact that the first expression is evaluated before the second expression as for the example shown above. As a consequence, the conditions have to be evaluated sequentially.

Both solutions for supporting the given for the conjunction and refinement of quantifiers rely on desugaring the expressions to a logically equivalent form.

\subsection{Rewriting Rules}
Both the conjunction and implication used to combine quantified expressions can be supported by rewriting the quantified expression to a form already supported before. The rewriting takes place after adding a condition if it was omitted as described above.

If the expression on the right-hand side of the implication is pure or a permission already supported, no rewriting is necessary. We desugare the expression by duplicating the variable declaration and condition. The trigger is duplicated, and should be valid for both sub-expressions.

\begin{longtable}{ p{1\textwidth} } 
	\(\mathbf{forall} \; x:T ::  \{trs\}\ c(x) \Rightarrow e_1(x) \ \&\&\ e_2(x)) \) \\
	\(\longmapsto (\mathbf{forall} \; x:T ::  \{trs\}\ c(x) \Rightarrow e_1(x)) \ \&\&\  (\mathbf{forall} \; x:T ::  \{trs\}\ c(x) \Rightarrow e_2(x)) \)
\end{longtable}

Considering the case where both quantifiers are permission-based, it is necessary to define the inverse function and injectivity for both sub-expressions separately. The rewriting rule only results in a minor overhead, since the evaluation of the condition \(c(x)\) is done twice for both quantifiers. This could however be cached. 

An implication \(A \Rightarrow (B \Rightarrow  C) \) is logically equal to  \((A \:\&\&\: B) \Rightarrow C\). Using this property, a refinement of a condition can be desugared using its logical equal by adding the boolean expression to the condition.

\begin{longtable}{ p{1\textwidth} } 
	\(\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x))\) \\
	\(\longmapsto \mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x)) \)
\end{longtable}

The rewriting function is described in Table \ref{rewrite}. We treat the pure quantifiers and quantified permissions for fields, predicates and magic wands as our base case and express the combination of quantifiers as one of those base cases. As soon as we encounter a pure quantifier, we do not rewrite it.

\begin{longtable}{| p{1\textwidth} |} 
\hline
rewrite \textbf{forall} \(x:T :: \{trs\}\ c(x) \Rightarrow Exp\) \{\\
res := Exp match \{\\
\ident case \(b\)  : \\
\ident \ident \textbf{forall} \(x:T :: \{trs\}\ c(x) \Rightarrow Exp\)\\
\ident case \(Exp_1 \ \&\&\ Exp_2\) : \\
\ident \ident rewrite(\textbf{forall} \(x:T :: \{trs\}\ c(x) \Rightarrow Exp_1) \ \&\&\  \)\\
\ident \ident \ident \textbf{forall} \(x:T :: \{trs\}\ c(x) \Rightarrow Exp_2\)) \\
\ident case \(b \Rightarrow Exp\) : \\
\ident \ident rewrite(\textbf{forall} \(x:T :: \{trs\}\ (c(x) \ \&\&\  b) \Rightarrow Exp\)) \\
\ident default  : \\
\ident \ident \textbf{forall} \(x:T :: \{trs\}\ c(x) \Rightarrow Exp\)\\
\ident \} \\
\ident \textbf{return} res \\
\}\\ \hline
\caption{Rewriting rules for combinations of quantifiers after adding a condition if necessary.}
\label{rewrite}
\end{longtable}

\subsection{Example}
Let's consider the example mentioned at the beginning of the section. As a first step we add the condition to conform to the structure handled in quantified permissions:

\begin{longtable}{ p{1\textwidth} } 
\textbf{forall} \(x:Ref :: (x\ in\ xs \Rightarrow (acc(x.f) \ \&\&\ x.f  = i)) \ \&\&\ (x\ in\ ys \Rightarrow acc(P(x))) \mapsto \) \\
\textbf{forall} \(x:Ref :: true \Rightarrow (x\ in\ xs \Rightarrow (acc(x.f) \ \&\&\ x.f  = i)) \ \&\&\ (x\ in\ ys \Rightarrow acc(P(x)))\) \\
\end{longtable}

We then proceed to rewrite the new expression according to the algorithm of Table \ref{rewrite}:
\begin{longtable}{ p{1\textwidth} } 
\textbf{forall} \(x:Ref :: true \Rightarrow (x\ in\ xs \Rightarrow (acc(x.f) \ \&\&\ x.f  = i)) \ \&\&\ (x\ in\ ys \Rightarrow acc(P(x)))\) \\
\(\longmapsto\) (\textbf{forall} \(x:Ref :: true \Rightarrow (x\ in\ xs \Rightarrow (acc(x.f) \ \&\&\ x.f  = i))) \ \&\&\ \) \\
\ident (\textbf{forall} \(x:Ref :: true \Rightarrow (x\ in\ ys \Rightarrow acc(P(x)))) \)\\
\(\longmapsto\) (\textbf{forall} \(x:Ref :: (true  \ \&\&\ \ x\ in\ xs ) \Rightarrow  (acc(x.f) \ \&\&\ x.f  = i)) \ \&\&\ \) \\
\ident  (\textbf{forall} \(x:Ref :: true \ \&\&\ \ x\ in\ ys \Rightarrow acc(P(x))) \) \\
\(\longmapsto\) (\textbf{forall} \(x:Ref :: (true  \ \&\&\ \ x\ in\ xs ) \Rightarrow  acc(x.f)) \ \&\&\ \)\\
\ident (\textbf{forall} \(x:Ref :: (true  \ \&\&\ \ x\ in\ xs ) \Rightarrow x.f  = i) \ \&\&\ \) \\
\ident (\textbf{forall} \(x:Ref :: true \ \&\&\ \ x\ in\ ys \Rightarrow acc(P(x))) \) \\
\end{longtable}

At the end of the rewriting, we translate the three forall expressions sequentially. 

\subsection{Implementation}
The implementation for supporting the combinations presented uses the rewriting rules mentioned above. As a first implementation, the rewriting was done separately for Carbon and Silicon. This would have permitted adapting the rules for one of the verifiers only at a later point if desired. We decided however to move the rewriting to the parsing of the program. Both Carbon and Silicon accept the same program with the already rewritten expressions.

%Nested Quantifiers
\section{Nested Quantifiers}
\label{nq}
In this section we present another adaption removing the restriction that a quantified permission may depend on one variable only. After applying the rewriting rules given in section \ref{rewriting}, there are two forms of nested quantifiers we decided to support.

In the first structure, all variables are defined upfront, allowing condition and expression to depend on all of them:\\

\begin{tabularx}{1\textwidth}{ X }
	\( \mathbf{forall} \; x_1:T_1, \dots, x_n: T_n ::  \{trs\}\ c(x_1, \dots, x_n) \Rightarrow \) \\
	\(e(x_1,  \dots, x_n)\)
\end{tabularx}\\

The expression \(e(x_1,  \dots, x_n)\) stands for any unquantified permission previously included in quantified permissions. Pure quantifiers of this form are already supported in Viper. For the support of this new quantified expression we present a new generalisation of the previously shown algorithms.\\

The second structure represents a truly nested quantifier, where a second forall expression occurs on the right-hand side of the implication. The following formula represents this form:\\

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\end{tabularx}\\

Here, the expression \(e(x_1, x_2)\) can, be any permission expression introduced before or another quantified expression. In order to support these expressions, we present a new rewriting rule.

Both formulas allow us to define more complex quantifiers, for example access rights to a matrix, without resorting to reformulate them. The set of allowed quantifier is extended to:
\begin{longtable}{ p{1\textwidth} } 
\textbf{forall} \(x_1: T_1, \dots, x_n : T_n :: \{trs\}\  Exp\),\\
\ident \( Exp := b\)  \\
\ident \ident \(|\ acc(e.f, p)\) \\
\ident \ident \(|\ acc(P(arg_1, \dots, arg_n), p)\) \\
\ident \ident \(|\ A \wand B\) \\
\ident \ident \(|\ Exp_1 \ \&\&\ Exp_2\) \\
\ident \ident \(|\ b \Rightarrow Exp\) \\
\ident \ident \(|\) \textbf{forall} \(x_1: T_1, \dots, x_n : T_n :: \{trs_2\}\  Exp\)\\
\label{combinations}
\end{longtable}

To support these nested quantifiers, we need to adapt the presented solution for quantified field, predicate and magic wands. How these approaches have to be adapted, is described in section \ref{multipleVars}. Additionally, we introduce a new rewriting rule for truly nested quantifiers  in section \ref{rewritesN}.

\subsection{Multiple quantifier variables}
\label{multipleVars}
For both verification condition generation and symbolic execution, the representation of the general location used to express the updated permission does not change. There is no need to change the definition of the symbolic heap chunks. The translation of the quantifier to its neutral form, however, does. Again, we need a way to retrieve the original variables using inverse functions. In order to do that, we introduce \(n\) inverse functions, each inverse function mapping from a general location to the value of one variable.

In order to translate the given permission to that form, we need to adapt the definition of inverse function. The new inverse function returns a value of type \(T_i\) corresponding to the original value of the ith quantifier variable given the arguments defining the general location. The adapted inverse functions for quantified field and predicate permissions can be seen in Figure \ref{nInv}.

\begin{longtable}{ p{1\textwidth} } 
\textit{/* Nested Field Quantifier */}\\
\textbf{function }\(inv_i(r: Ref): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow inv_i(e (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  r:Ref ::  c(inv_1(r), \dots, inv_m(r) \Rightarrow e (inv_1(r), \dots, inv_m(r)) = r \) \\
\\
\textit{/* Nested Predicate Quantifier */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),â€¦,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_m(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_m(a_1,\dots, a_n )) = a_i \) \\
\caption[Nested Inverse Functions]
   {Inverse Function definitions for nested quantifiers for quantified field and predicate permissions, for all inverse functions \( i\), where \( 1 \leq  i \leq  m \), \(m\) being the number of quantifier variables.}
\label{nInv}
\end{longtable}

Using these inverse functions also enforces us to restrict the allowed expressions for nested quantifiers. \(e(x)\) has to be injective. These new conditions are shown in figure \ref{nInjectivity}.

\begin{longtable}{ p{1\textwidth} } 
\textit{/* Nested Field Quantifier */}\\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n, y_1:T_1, \dots, y_n:T_n :: (x_1 != y_1 || \dots ||  x_n != y_n) \ \&\&\ c(x_1, 
\dots, x_n) \ \&\&\ c(y_1, \dots, y_n) \Rightarrow e(x_1, \dots, x_n) != e(y_1, \dots, y_n)\) \\
\\
\textit{/* Nested Predicate Quantifier */}\\
\(\ \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n, y_1:T_1, \dots, y_n:T_n :: (x_1 != y_1 || \dots ||  x_n != y_n) \ \&\&\ c(x_1, 
\dots, x_n) \ \&\&\ c(y_1, \dots, y_n) \Rightarrow (e_1(x_1, \dots, x_n) != e_1 (y_1, \dots, y_n) || \dots || e_n(x_1, \dots, x_n) != e_n (y_1, \dots, y_n)\) \\
\\
\caption[Rewriting Rules for Nested Inverse Functions]
   {New injectivity definition for nested quantifiers.}
\label{nInjectivity}
\end{longtable}

As an additional change to the approaches, any occurrence of the inverse function is replaced by the tuple of all inverse function as defined above. We display the altered approach for inhaling a nested quantified field permission for verification condition generation in Table \ref{qfnInhaleCond} and for symbolic execution in Table \ref{qpnInhaleSyn} (TODO). Other approaches are adapted analogously for nested quantifiers, but are omitted here.

%triggering
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale forall } \(x_1:T_1, \dots, x_n:T_n :: c(x) \Rightarrow \) \\
\ident \( acc(e(x_1, \dots, x_n).f, p(x_1, \dots, x_n)) \) \{\\
\ident Let \textit{qpMask} be a new Mask\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(inv_i\)  be a fresh function of type  \( Ref \Rightarrow T_i \) \\
\ident \textbf{assume } \( \forall x_1:T_1, \dots, x_n:T_n  ::\{\underline{e}(x_1, \dots, x_n)\}\ \underline{c}(x_1, \dots, x_n)  \Rightarrow \) \\ 
\ident \ident \(inv_i(\underline{e}(x_1, \dots, x_n)) = x_i \) \\
\ident \textbf{assume\ } \( \forall r:Ref ::\{inv_1(r)\}, \dots, \{inv_n(r)\}\ c(inv_1(r), \dots, inv_n(r))  \Rightarrow \) \\
\ident \ident \(\underline{e}(inv_1(r), \dots, inv_n(r)) = r \) \\
\\
\ident \textit{/* all receiver is non-null */} \\
\ident \textbf{assume } \( \forall x_1:T_1, \dots, x_n:T_n  ::\{\underline{e}(x_1, \dots, x_n)\}\ \underline{c}(x_1, \dots, x_n)  \Rightarrow \) \\
\ident \ident \(\underline{e}(x_1, \dots, x_n)) != null \) \\
\\
\ident \textit{/* assume e(x) is injective */} \\
\ident \textbf{assume} \(\forall x_1:T_1, \dots, x_n:T_n, y_1:T_1, \dots, y_n:T_n :: \{\}\ (x_1 != y_1 || \dots ||  x_n != y_n) \ \&\&\ c(x_1, 
\dots, x_n) \ \&\&\ c(y_1, \dots, y_n) \Rightarrow \underline{e}(x_1, \dots, x_n)\ != \underline{e}(y_1, \dots, y_n)\) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{qpMask(r, f)\}\ \{inv_1(r), \dots, inv_n(r)\}\) \\
\ident  \ident \ident \ident \ident \(c(e(r)) \Rightarrow qpMask(r, f) = Mask(r.f) - p(inv_1(r), \dots, inv_n(r))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{ qpMask(r, f)\}\{ inv_1(r), \dots, inv_n(r)\}\)\\
\ident  \ident \ident \ident \ident \( \ \neg c(e^{-1}(r)) \Rightarrow qpMask(r, f) = \) Mask \((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:Object, f_o:Field :: \{Mask(o, f) \}\ \{ qpMask(o, f)\}\) \\
\ident  \ident \ident \ident \ident \((f_o != f) \Rightarrow qpMask(o , f) = \) Mask \((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon nested quantified field inhale]
   {Translating nested quantified field inhale operation.}
\label{qfnInhaleCond}
\end{longtable} 

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x_1:T_1, \dots, x_n:T_n:T :: c(x_1, \dots, x_n) \Rightarrow acc(e(x_1, \dots, x_n).f, p(x_1, \dots, x_n))\) \{\\
\ident Let \(y_1, \dots, y_n\) be a fresh symbolic constant of type \(T_1, \dots, T_n\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y_1, \dots, y_n)) := eval(h_0, \pi_0, c(y_1, \dots, y_n))) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{e}(y_1, \dots, y_n)) := eval(h_0, \pi_1 \cup \{\underline{c}(y_1, \dots, y_n)\}, e(y_1, \dots, y_n)) \)\\
\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y_1, \dots, y_n)) := eval(h_0, \pi_2, p(y_1, \dots, y_n)) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y_1, \dots, y_n)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(inv_i\)  be a fresh function of type  \(Ref \rightarrow T_i\) for all \(1 <= i <= n\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall r: Ref \cdot \underline{c}(inv_1(r), \dots, inv_n(r))  \Rightarrow\) \\
\ident \ident \ident \ident \ident \ident \ident \(\underline{e}(inv_1(r), \dots, inv_n(r)) = r \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x_1:T_1, \dots, x_n:T_n \cdot \underline{c}(x_1, \dots, x_n)  \Rightarrow \) \\
\ident \ident \( (inv_1(\underline{e}(x_1, \dots, x_n)) = x_1)  \ \&\&\ \dots \ \&\&\ (inv_n(\underline{e}(x_1, \dots, x_n)) = x_n) \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \underline{c}(inv_1(r), \dots, inv_n(r))\ ?\) \\
\ident \ident \ident \ident \ident \ident \ident \( \underline{p}(inv_1(r), \dots, inv_n(r)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Inhaling a Nested Quantified Field Permission]
   {These symbolic execution rules for inhaling a nested quantified field permission.}
\label{qpnInhaleSyn}
\end{longtable}


\subsection{Rewriting Nested Quantified Permissions}
\label{rewritesN}
If an expression is truly nested, we rewrite that expression to the newly established base cases by moving the additional variables to the front. This does not change the expression, but allows us to reuse the approach mentioned above. The trigger of the rewritten epxression has to combine all combination of both trigger sets to include all variables. If at least one triggersets are omitted, the new trigger will be empty.

The rewriting rules are displayed in Table \ref{nRewriting}.

\begin{longtable}{ p{1\textwidth} } 
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident     \( ( \mathbf{forall \ } y_1:T_{n+1}, \dots, y_m: T_{n+m}:: \{trs_2\} \)\\
\ident \ident \ident  \(c_2(x_1, \dots, x_n, y_1, \dots, y_{m}) \Rightarrow e(x_1, \dots, x_n, y_1, \dots, y_{m}))\)
\\
\( \longmapsto \mathbf{forall \ }  x_1:T_1, \dots x_n:T_{n}, y_1: T_{n+1}, \dots, y_m: T_{n+m} ::  \{trs_1 \times trs_2\}\ \) \\ 
\ident \ident \ident \(( c_1(x_1, \dots, x_n) \:\&\&\:   \ c_2(x_1, \dots, x_n, y_1, \dots, y_m) )  \Rightarrow \) \\
\ident \ident \ident  \(e(x_1, \dots, x_n, y_1, \dots, y_m)) \) \\
\caption[Nested Inverse Functions]
   {Additional Rewriting Rules in order to support forall expressions within quantifiers.}
\label{nRewriting}
\end{longtable}

\section{Evaluation}
\label{evaluation}
In order to evaluate the performance of the support of quantified predicates and combinations in Viper, we ran a set of viper programs on Carbon and Silicon.

%test files
The first set of test file test the implementation of quantified predicates for different number of predicate arguments and snapshot size. qqpprod\_arity tests inhaling quantified predicate permissions, spprod\_arity inhaling single predicate permissions for quantified predicates. The same distinction is made for exhaling predicates. Additionally there is a test for the operations fold, unfold and unfolding.

Generally speaking, Silicon verifies a bit faster than Carbon. Inhaling a single quantified predicate permission runs faster in Carbon, since it treats them same as a single unquantified predicate permission.

As a second test set, we consider a bunch of small examples...

The experiments were measured on a machine with an Intel Core i7-4700HQ 2.4GHz, 16GB RAM, running Windows 10 x64 with SSD. The measurements are shown in Figure \ref{timings}. The measured time corresponds to the average of 10 runs, where . The startup time of JVM are not included. The standard-deviation for the test cases was negligible.

\begin{longtable}{ | p{0.4\textwidth} | p{0.2\textwidth}| p{0.2\textwidth} | p{0.2\textwidth}|}
\hline
{\bf Program} & {\bf Size (LOC)} & {\bf Carbon}&  {\bf Silicon} \\ \hline
test.sil & 10 & 0.5s & 0.4s \\
\hline
\caption[run-time measurements]
   {TODO.}
\label{timings}
\end{longtable}

\section{Conclusion an Future Work}
This report generalised the suport of quantified field permissions, adapting the solutions implemented in Silicon and Carbon to support quantified predicate and magic wand permissions. Additionally we described the adaptions necessary to allow nested quantified permissions of all mentioned location types. To improve user-friendliness, we additionally provided four rewriting rules. These rules allow omitting a condition on declaration, the combination of pure and permission-based quantifiers as well as multiple nested forall statements. We implemented quantified predicate permissions and the rewriting rules for combinations in both of verifiers of Viper.

As future work, the implementation could be extended to include quantified magic wands, as well as nested quantifiers. Additionally, the introduction of a forach statement would allow applying a certain operation for multiple elements, which would allow the unfolding of a set of predicates, improving the usability of quantified predicate permissions.

\bibliographystyle{unsrt}
\bibliography{report}
\newpage
\section{Appendix}
\subsection{A}
This section holds various small changes done for the impementations in Silicon and Carbon.

\subsection{wilcards within Quantified permissions in Carbon}
When inhaling, the wildcard is assumed to be some arbitrary value. 

When exhaling, we define constrain the value of the wildcard to be smaller than the permission held for all locations. The implementation was not checking whether we posess any permission to the set of fields indicated by the quantifier. As a consequence, it was possible to exhale permissions to using wildcards in all cases.

As a correction, we added a check, asserting that for all locations satisfying the condition, we possess a strictly positive permission amoung.

\subsection{B}
\includepdf[pages={1}]{declaration.pdf}
\end{document}