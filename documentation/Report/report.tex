\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{tabularx}
\usepackage{listings}

\lstset{
         numbers=left,
 }

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Abstract}
\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs including shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} assosciate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a randomn access pattern in an array.

The paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language Silver. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Silver handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express pointwise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adpation of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

...section . deals with .

\section{Background}
%Permissions in general
In this chaper we give an overview of the theory needed to understand the proposed generalisation of quantified permissions, which is intended as an extenstion to the support already integrated in Viper\cite{viper}.

Viper is an verification infrastructure for permission-based reasoning and enables the development of program verifiers based on permission logics. It is designed to facilitates the implementation of verification techniques for programs, allowing developers to focus on the abstraction of higher-level language features to its intermediate verifcation language. Currenlty, it includes an intermediate verification language \textit{Silver}, two automatic back-end verifiers based on it and several front-ends for programming languages.

Permission logics were designed to define which locations of a heap are accessible. Viper works with fractional permissions between 0 and 1, where 1 denotes full permissions, which is equal to write and read permission, and any permission greater than 0 allowing to read values of a location. Both permissions and values of a location are stored in a heap chunk. When checking whether we posess enough permission for a specific location, we iterate through the heap chunks.
Assertions may only depend on locations with permission. Reaoning abuot properties can be reduced to inhaling and exhaling assertions. Inhaling is equal to adding the permission denoted or an assume in case of a pure assertion. Exhaling translates to removing permission or asserting a property in case of a pure assertion. If the permission of a location is lost, we also lose information about its value.

The two back-end verifiers are called \textit{Carbon} and \textit{Silicon}. 

\textit{Carbon}  is based on verification condition generation. It translates the given silver program to Boogie\cite{leino2008boogie}, which proves the generated code.%continue

\textit{Silicon} is based on symbolic execution. It is based on the SMT solver Z3\cite{de2008z3} and Smallfoot-style Symbolic Execution\cite{berdine2005smallfoot}, where the symbolic state is stored in heap chunks, holding permission and values for specific locations, and path conditions holding properties obtained while evaluating or executing commands.
%Smallfoot-style Symbolic Execution: In successor tools: VeriFast, jSTar and Viper: heap chunks also predicates...

\subsection{Silver}
overview of syntax
%fields, methods, functions, predicates, custom domains.

\subsection{Recursive Predicates}

Recursive Predicates\cite{parkinson2005separation} are typically used as part of separation logic to specify linked data structures such as lists and trees. Its definition consists of a name,  list of formal parameters and a body. 
Since predicates can be recursive, for example in case of the example in figure \ref{rec}, and the predicate could potentially be unrolled endlessly, Silver introduces a predicate instance seperatly from its body.
The permission of the predicate may be exchanged for its body via \textit{unfold}, whereas \textit{fold} exchanges the properties of the body for the permission of the predicate. Additionally, \textit{unfolding} additionally allows to temporarily unfold a predicate.

%example recursive
\begin{figure}[h]
  \centering
\begin{lstlisting}
field val: Int
field next:Ref

predicate list(r:Ref)
{
    acc(r.val) && acc(r.next) && (r.next != null ==> list(r.next))
}
\end{lstlisting}
\caption[recursive predicate]
   {recursive predicate example}
\label{rec}
\end{figure}


%example
\begin{figure}[h]
  \centering
\begin{lstlisting}
field f: Int

predicate pred(r:Ref)
{
    acc(r.f)
}

method m1(r:Ref)
requires acc(pred(r))
ensures acc(pred(r))
ensures unfolding pred(r) in r.f == 0
{

    unfold pred(r)
    r.f := 0
    fold pred(r)
}
\end{lstlisting}
\caption[predicate example]
   {Simple predicate example. By unfolding the predicate in line 14, we loose the access right to the predicate \textit{pred(r)} and gain the access rights to \textit{r.f}. This allows us to write to the field. By folding the predicate again, we regain the access rights to the predicate, which allows us no exhale the predicate in line 10. Unfolding temporarily unfolds the predicate \textit{pred(r)}, after which we obtain the permission to read the field \textit{r.f}, and also the value of that field. As a result, the assertion \textit{r.f == 0} should always evaluate to true.}
\end{figure}

\subsection{Magic Wands}
A magic wand\cite{magicwand} A --* B is a binary connective, which allows that given assertion A is satisfied in the current state, it can be exchanged for the assertion B. Similarly to recursive predicates, the exchange can be initiated by \textit{apply}, whereas \textit{unapply} exchanges assertion B for assertion A. Viper also supports a heuristic to automate when these assertions are exchanged. This functionality can be used to keep track of partial data structures during a traversal.

%example please. Explain more closely how apply and unapply work. Cite other stuff?

%Quantified Field Permissions
\subsection{Quantified Field Permissions}
The generalisation of quantified permissions as defined before is building on top of the concept presented for quantified field permissions of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}.
It defines a new definition for quantified heap chunks and an approach to inhale and exhale quantified field permissions.

%Quantified Field Chunk
\paragraph{Quantified Field Chunk}
Heap chunks are generalised to denote permission to an unbounded number of locations simultaneously.
In order to avoid an existential query in making a quantified permission chunk depending on the variable of the original forall expression, an inverse function is introduced, which maps a location to the initial value of the variable. To guarantee the existence of an inverse function, it is necessary that the expression denoting the receiver must be injective, which does however not restrict the data structures that can be handled by this approach as long as correctly specified.This allows us to define a quantified permission chunk of the form r.f -> [v(r), p(r)], where r represents the quantified receiver, p(r) an expression denoting the permission amount and v(r) a value map used to hold the values of the locations.
General form: r.f -> [v(r), c(inv(r)) ? p(inv(r)) : 0)]

%Inhale
\paragraph{Inhale}
Given a symbolic heap, a path condition and a quantified field permission, inhaling returns an updated heap and path conditions.
Inhaling generates a new quantified heap chunks  r.f -> [v(r), c(inv(r)) ? p(inv(r)) : 0)] after evaluating the condition, receiver expression and permission expression, as well as introducing the inverse function inv and a fresh value map v(r).
The inverse function is only defined if the given condition c(x) or c(inv(r)) holds.The definition adds two quantified conditions to the path condition starting from a general location and the original variable types variable.

%injectivity

%Exhale
\paragraph{Exhale}
Exhaling again evaluates the condition, receiver expression and permission expression, checks the injectivity of the receiver expression, introduces its inverse function and proceeds to remove the permission from the heap.
The removing is done by walking through all quantified field chunks with the same field f, removing permissions greedily or fails if there is not enough permission. Updating chunks is expressed via pointwise-defined functions defining the permission amounts.

%Quantified Fields inverse function and injectivity definitions.
\begin{tabular}{ l || c }
& Quantified Field Permission \\ \hline
General Form & \( \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(e(x).f, p(x)) \)  \\
Inverse Functions &   \( \mathbf{forall} \   x:T :: c(x) \Rightarrow inv(e(x)) == x \) \\
& \( \mathbf{forall} \   r:Ref :: c(inv(r)) \Rightarrow e(inv(r)) == r \) \\
Injectivity &  \( \mathbf{forall} \   x_1:T, x_2:T :: (x_1 != x_2)\ \&\& c(x_1) \ \&\& c(x_2)  \Rightarrow e(x_1) != e(x_2) \)\\ \hline
\end{tabular}

%inhale
\newcommand*{\ident}{\hspace*{0.5cm}}
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{e}(y)) := eval(h_0, \pi_0, e_y)) \)\\
\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_0, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow Ref\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall r: Ref \cdot c(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot c(e(x))  \Rightarrow e^{-1}(\underline{e}(r)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Inhaling a Quantified Field Permission]
   {Symbolic execution rules for inhaling a quantified field permission. Eval. Check...}
\end{figure}

%exhale
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check} \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land \underline{e}(y_1) = \underline{e}(y_2) \Rightarrow  y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var} h_1 :=  remove(h_0, \pi_6, f, (\lambda r \cdot \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified field permission. Eval. Check...}
\end{figure}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all chunks in given state for field \(f\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_f := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(r.f  \mapsto [v_i(r), q_i(r)] \in h_f\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda r \cdot min(q_i(r), q_{needed}(r))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda r\cdot q_{needed}(r) - q_{current}(r)) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_f := h'_f \cup \{r.f \mapsto [v_i(r), (q_i(r) - q_{current}(r))] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(r) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_f)  \cup h'_f \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Field Permission]
   {Symbolic execution rules for removing a quantified field permission. Eval. Check...}
\end{figure}

%summarize
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{summarize}\(\ (h_0, f) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for field \(f\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \(def := \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \(perm := \lambda r \cdot 0\) \\
\ident \textbf{foreach } \((r.f \mapsto [v_i(r), q_i(r)]) \in h_f \) \textbf{do:} \\
\ident \ident \(def := def \cup \{ \forall r \cdot 0 < q_i(r)  \Rightarrow v(r) = v_i(r) \} \) \\
\ident \ident \(perm := \lambda r \cdots (perm(r) + q_i(r)) \) \\
\ident \textbf{return} \((v, def, perm)\) \\
\}\\ \hline
\end{tabularx}
\caption[Summarize Quantified Field Permissions]
   {Symbolic execution rules for summarizing quantified field permissions. Eval. Check...}
\end{figure}


\section{Quantified Predicate Permissions}
In this section we present an adpation of the mentioned solution of quantified field permissions support to allow the support of quantified predicate permissions. 
As the general form we consider the adaption of the canonical form presented for quantified predicate permissions: 
\begin{equation}
 \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(pred(e_1 (x),…,e_n (x)), p(x)), 
\end{equation}
where \(c(x)\) is a boolean expression,\( e_i(x)\) denotes an expression expression of the predicate \textit{pred} ith's arguments and \(p(x)\) permission expression.

Introducing this new form allows us to express permission to more complex structures such as a set of lists.

\subsection{General Approach}
%Technical Challenges of it
To explain the adaption needed for the implementation, we again discuss the aswers to the following questions:
\begin{enumerate}
\item How to model the program state, including permissions and values?
\item How to check for a permission in a state?
\item How to add and remove permissions to and from a state?
\item How to evaluate (heap-dependent) expressions in a state?
\item When to preserve (frame) an expression's value across heap changes?
\end{enumerate}
%Example

The first problem is handled in section \ref{shr}, the second and third in section \ref{qpp} and the fourth in section \ref{qppVals}. 

\subsubsection{Symbolic Heap Representation} \label{shr}
In order to reason about quantified predicate permissions, it is necessary to define a symbolic heap representation for a potentially unbound set of predicates simultaneously. In the previous design, the quantified field heap chunk is defined by the field name, where permission and value are defined using a general location reference \(r\).
For quantified predicate chunk we use the predicate instead of the field as identification, where we use a set of general arguments to express permission and values. The general form of such a heap chunk conforms to:
\begin{equation}
	\mathbf{pred}(\mathrm{arg_1, ..., arg_n})\mapsto [s(\mathrm{arg_1, ..., arg_n}), p(inv(\mathrm{arg_1, ..., arg_n}))]
\end{equation}
where the values of the value map conform to the snapshot of a predicate instantiation.

In order to translate the given permission to that form, we need to adapt the definition of inverse function. The new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier given the arguements of the predicate. The adaptend inverse function is defined as:\\

\begin{tabularx}{1\textwidth}{ X}
\textbf{function }\(inv(a_1:A_1, \dots, a_n:A_n): T\) \\
\( \mathbf{forall \ }  x:T :: c(x) \Rightarrow inv(e_1 (x),…,e_n (x))==x \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv(a_1, …,a_n )) \Rightarrow e_i (inv(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}\\

Similar as for quantified field permissions, we have to restrict the allowed expression terms as a result. The combination of the expressions has to be injective.

\subsection{Treatement of Permissions} \label{qpp}
With the new quantified predicate heap chunks defined above, we redefine \(inhale\) and \(exhale\) operations for quantified predicate permissions.

\subsubsection{Inhaling}
The adapted symbolic execution rules for a inhaling a quantified permission can be seen in figure \ref{qpInhale}. It differs in the definition of the inverse funciton, as well as the values of the value map.

As before, inhaling a quantified predicate permission updates a given state and returns an updated heap and path condition.
Similarly the quantified field expression, the condition, argument expressions and permission expression are evaluated as a frist step.

The inverse function is intorduced anagolous to a quantified field permission and further defined by adding two constraints to the path condition. As mentioned before, the cardinality of the inverse function may vary with different predicates, whereas the definition and constraints are identical for the same predicate.

We introduce a value map, which maps a concrete instantiation of a predicate defined by its arguements to the snap of that predicate. This snap value is used to retrieve information during an unfold or unfolding. On introduction, all snapshots are unknown.
%domain?

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x)) \) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_1}(y)) := eval(h_0, \pi_0, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow A_1, \dots, A_n\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Inhaling a Quantified Field Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission.}
\label{qpInhale}
\end{figure}

\subsubsection{Exhaling}
In order to exhale a quantified predicate permission, we need to adapt the injectivity check, as well as the inverse function definition. The algorithm is defined in figure %\ref{qpExhale}.

After evaluating the expressions denoted by the quantified predicate permission, we check the injectivity analogously to a quantified field permission before introducing the inverse functions as defined in the inhaling. For the injectivity check, it is sufficient that at least one argument expression differs on the evaluation of any two unequal variables fo type T satisfying the condition. %Example

%exhale
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission.} %expand description: check, remove....
\label{qpExhale}
\end{figure}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Field Permission]
   {Symbolic execution rules for removing a quantified field permission. Eval. Check...}
\label{qpRemove}
\end{figure}

The definition of removing a permission amount from a quantified epxression does not need to be changed except for the filtering of the quantified chunks. After that, we again iterate through these chunks, taking permission greedily, and raising an error if not enough permission is available. The updated definition can be seen in figure %\ref{qpRemove}.

\subsection{Treatment of Symbolic Values} \label{qppVals}
The predicate snapshot is used during unfold, fold and unfolding, where unfold corresponds to a field read and fold to field write in the context of a quantified field permission.

%overview
\subsubsection{Unfold} 
\label{qUnfold}
Unfolding a predicate corresponds to exhaling a single predicate, after which we inhale the body of the predicate. The body of the predicate and the information of the values we gain access to, is represented by a snapshot, which in the case of a quantified predicate corresponds is stored in the value map of a quantifier.

%example?

Unfold exhales the permission to the predicate with given arguments as described above. Exhaling will provide you with the snapshot of the predicate, which is inhaled - containing permission and values designated by the snapshot.

\subsubsection{Fold} 
\label{qFold}
Exhales the body of the predicate and stores its snapshot in the  snapshot function of the newly generated quantified predicate chunk.

\subsection{Unfolding}
Unfolding is desugared as before, by using the unfold definition of  \ref{qUnfold} on the predicate, evaluating the expression e and finally folding the predicate as described in \ref{qFold}.

\subsection{Framing}

%silicon
\subsection{Silicon}
The implementation of Siilicon is very close to the approach presented in section 2.
Analogous to the quantified field permissions unquantified predicates are also treated as quantified permissions, where the permission is restricted to the specific predicate argument values.

\subsubsection{Producing multiple Quantified Predicates}
\begin{itemize}
\item create new quantified predicate heap chunk
\item declare inverse functions and two assumtpions declaring its properties as defined above.
\end{itemize}

Z3 Code-wise: The assumption of non-null fields is not necessary.

\subsubsection{Producing a single Quantified Predicate}


%Quantified Magic Wands
\section{Quantified Magic Wands}
A representation of a Magic Wand\cite{magicwand} depends on the form of de wand definition and may have multiple arguments. As a consequence, the definition for inverse funcitons and injectivity are analogous to a quantified predicate permission.

%example

%Quantifiers
\section{Combinations of Quantifiers}
In order to avoid declaring unnecessary forall expression with the condition or dependency, it is desirable to be able to express combinations of pure and permission-based specifications. We considered the following combinations:
\begin{itemize}
\item conjunction of any mix of pure and permission-based quantifiers:
%TODO link to specific definition
\begin{equation}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))),
\end{equation}
where {\it trs} are the triggers of the forall expression, {\it c(x)} is  a boolean expression,{\it e(x)} denotes an expression which could either be a pure expression or a permission expression depending on x, in which case {\it e(x)} consists of an injective mapping to a set of locations and some permission function {\it p(x)} as described in the chapters before.

\item implication of a boolean expression and a permission-based quantifier:
%TODO: link?
\begin{equation}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x)),
\end{equation}
with the same definitions of .
\end{itemize}

Please note that forall expressions which are entirely pure are not considered in this chapter.

%TODO

We considered two ways to expand the given approach to this setting: desugaring the forall expression to the form we defined before or adapt the interpretation to allow for such things. As it is, combinations may be depending on each other, which means each conjunction as to be evaluated sequentally. As a result there is barely any gain in not desugaring the terms mentioned before. Therefoe we suggest two rewriting rules to desugare conjunctions and implications within a forall expression.

\subsection{Rewriting Rules}
\label{rewriting}
A conjunction of two expression is desugared by rewriting the entire forall expreeion into two forall expressions, dublicating variables, condition and triggers. Triggers are expected to be valid for both newly generated forall expressions.

\begin{equation}
\begin{aligned}
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x)  \Rightarrow e_1(x)) \ \&\& \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x) \Rightarrow  e_1(x))
\end{aligned}
\end{equation}

An implication is rewritten to the logical equivalent of the conjunction of both conditions on the left-hand side of the implication.
\begin{equation}
	\mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x))
\end{equation}

\subsection{Implementation}
The rewriting rules are implemented in the parser. As a result they are exectued for both Carbon and Silicon.

User-given triggers are handed over. Since suitability of the triggers is not tested for each rewritten forall expression, triggers need to suite all and clauses of an expression. Pure quantifiers are not rewritten. 
%TODO
 In Carbon, triggers are generated after the rewriting step in case of empty triggers.


%Nested Quantifiers
\section{Nested Quantifiers}
%Why nested quantifiers?
In this section we present another adaption removing the restriction that a quantified permission may depend on one variable only. After applying the rewriting rules given in section \ref{rewriting}, there are two forms of nestes quantifiers which are desirable to support.

In the first structure, all variables are defined at once, allowing condition and expression to depend on all of them:\\

\begin{tabularx}{1\textwidth}{ X }
	\( \mathbf{forall} \; x_1:T_1, \dots, x_n: T_n ::  \{trs\}\ c(x_1, \dots, x_n) \Rightarrow \) \\
	\(e(x_1,  \dots, x_n)\)
\end{tabularx}\\

The expression \(e(x_1,  \dots, x_n)\) stands for any unquantified permission where we presented a quantified solution in the previous chapters, Pure quantifiers of this form are already supported in Viper. For the support of this new quantified expression we present a new generalisation of the previously shown algorithms in section \ref{generalN}.\\

The second structure represents a truly nested quantifier, where on the righthand side of the implication. The following formula represents such a form with two quantifiers:\\

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\end{tabularx}\\

Here the expression \(e(x_1, x_2)\) can, as mentioned before, be any permission expression introduced or another quantified expression. As a solution we present a new rewriting rule in section \ref{rewritesN}.

Both formulas allow us to define more complex quantifiers, for example access rights to a matrix, without resorting to reformulate them 

\subsection{Generalisation for Nested Quantified Permissions}
\label{generalN}




\subsubsection{Symbolic Heap Representation} \label{shr}
By changing the number of variables a quantifier depends on, we do not need to change the design of the heap chunks itself. Both the types and arguments do not change. The way to translate an argument to its neutral form, however, does. We need a way to retrieve the original variables using inverse functions. In order to do that, we introduce \(n\) inverse functions, which each map from a general location to the value of one variable.

In order to translate the given permission to that form, we need to adapt the definition of inverse function. The new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier given the arguements of the predicate. The adapted inverse functions for quantified field and predicate permissions can be seen in figure \ref{nInv}.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{ X}
\textit{/* Nested Field Quantifie */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),…,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_n(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_n(a_1,\dots, a_n )) = a_i \) \\
\\
\textit{/* Nested Predicate Quantifier */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),…,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_n(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_n(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}
\caption[Nested Inverse Functions]
   {Inverse Function definitions for nested quantifiers for quantified field and predicate permissions, for all inverse functions \( i\), where \( 1 \leq  i \leq  n \).}
\label{nInv}
\end{figure}

Using these inverse functions also enforces us to restrict the allowed expressions for nested quantifiers. \(e(x)\) has to be injective. These new conditions are shown in figure.


\subsubsection{Treatement of Permissions} \label{qpp}
With the new quantified predicate heap chunks defined above, we redefine \(inhale\) and \(exhale\) operations for quantified predicate permissions.

Inhaling a nested quantified permission is now done using the inverse definition shown before. The newly generated heap chunk uses the inverse funcitons to whether the conditions of the general locations are met, as well as the determination of the permission amount itself.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x)) \) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_1}(y)) := eval(h_0, \pi_0, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow A_1, \dots, A_n\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Inhaling a Quantified Field Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission.}
\label{qpnInhale}
\end{figure}

Exhaling a nested quantified permission is done analogously. The check for the inverse function is also altered accordingly.

%exhale
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission.} %expand description: check, remove....
\label{qpnExhale}
\end{figure}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Field Permission]
   {Symbolic execution rules for removing a quantified field permission. Eval. Check...}
\label{qpnRemove}
\end{figure}

The definition of removing a permission amount from a quantified epxression does not need to be changed except for the filtering of the quantified chunks. After that, we again iterate through these chunks, taking permission greedily, and raising an error if not enough permission is available. The updated definition can be seen in figure %\ref{qpRemove}.

\subsection{Treatment of Symbolic Values} \label{qppVals}
The predicate snapshot is used during unfold, fold and unfolding, where unfold corresponds to a field read and fold to field write in the context of a quantified field permission.


\subsection{Rewriting Rules for Nested Quantified Permissions}
\label{rewritesN}

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\\
    \( \longmapsto\)\\
\\
      \(\mathbf{forall \ }  x_1:T_1, \dots x_{n+1}:T_{n+1} ::  \{trs_1 \times trs_2\}\  \) \\ 
\ident \ident \ident \(( c_1(x_1, \dots, x_n) \:\&\&\:   \ c_2(x_1, \dots, x_{n+1}) )  \Rightarrow  e(x_1, \dots, x_{n+1}))\) \\
\end{tabularx}\\

\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}