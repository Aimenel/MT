\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{longtable}

\lstset{
         numbers=left,
 }

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}
\newcommand*{\ident}{\hspace*{0.5cm}}

\maketitle
\newpage
\tableofcontents
\newpage
\section{Abstract}
\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs as shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} associate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a random access pattern in an array.

The paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language Silver. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Silver handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express point-wise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adaption of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

...section . deals with .

\section{Background}
%Permissions in general
In this chapter we give an overview of the theory needed to understand the proposed generalisation of quantified permissions, which is intended as an extension to the support of quantified fields already integrated in Viper\cite{viper}\cite{viper2014}.

Viper is an verification infrastructure for permission-based reasoning and enables the development of program verifiers based on permission logics. It is designed to facilitates the implementation of verification techniques for programs, allowing developers to focus on the abstraction of higher-level language features to its intermediate verification language. Currently, it includes an intermediate verification language \textit{Silver}, two automatic back-end verifiers \textit{Carbon} and \textit{Silicon}, as well as several front-ends for programming languages. A front-end translate the programming language into \textit{Silver} and further uses one or both verifiers for verification.

\textit{Carbon}  is based on verification condition generation. It translates the given silver program to Boogie\cite{leino2008boogie}, which proves the generated code.
state is modelled by maps representing the heap and permissions held.

\textit{Silicon} is based on symbolic execution. It is based on the SMT solver Z3\cite{de2008z3} and Smallfoot-style Symbolic Execution\cite{berdine2005smallfoot}, where the symbolic state is stored in heap chunks, holding permission and values for specific locations, and path conditions holding properties obtained while evaluating or executing commands.
state represented by heap chunks and path conditions

\subsection{Overview}
This section presents on overview of Viper\cite{viper}\cite{viper2014}, including the syntax and features permissive in Silver, as well as the general approaches for verifying them in Carbon and Silicon. 

Silver has a fixed heap implementation. A program consists of global declaration called fields, predicates, functions, methods, and custom domains.

%fields, methods, functions, predicates, custom domains.
\paragraph{Permissions: }
Permission logics were designed to define which locations of a heap are accessible. Silver is based on fractional permissions with values between 0 and 1.  1 denotes full permissions, which is equal to write and read permission, and any permission greater than 0 allowing to read values of a location. In Silver, there are various constructs allowing to transfer permission. The one most used is the accessibility predicate acc\((e_1.f, e_2)\), denoting exclusive permission to a field location \textit{f} of the reference denoted by \(e_1\). The permission amount is expressed by \(e_2\). If the permission amount is omitted, the permission amount corresponds to full permission.

\paragraph{Program State: }
The program state of Silver includes the current heap, as well as the assignments to program variables. The state can be manipulated by assertions, which may only depend on locations with permission. Reasoning about properties can be reduced to inhaling and exhaling assertions. Inhaling is equal to adding the permission if the expression is permission-based, or assuming a property if the assertion is pure. Exhaling translates to removing permission or asserting. If the permission of a location is lost, we also lose information about its value.

\paragraph{Types and Domains: }
%multiset
The built-in primitive types of Silver consists of  Int , Bool, Ref (Reference) and Perm.  Additionally,  polymorphic sequences such as Seq[T] and sets Set[T] are included. Domains further allow to define custom domain types, which may include axioms and functions to define its properties.

\paragraph{Fields: }
The globally defined fields exist for all references and have a designated type. Together with predicates and magic wands, they make up the heap. Values of the heap can only be accessed if sufficient permission is held.

\paragraph{Methods: }
Methods consists of a name, arguments, pre- and postconditions, as well as its body. The preconditions must include sufficient permissions to allow all heap dereferences used in the method body. During verification, the verifiers inhale the preconditions and try to prove the postconditions after the execution of the body.

\paragraph{Functions: } %check please
Similarly to methods, functions consist of a name, preconditions, postconditions and optionally a body. Contrary to methods, the expressions within the body are restricted and must be pure. They may be used in assertions and axiom definitions.

\paragraph{Example: }
\begin{figure}[h]
  \centering
\begin{lstlisting}
function read(a: IArray, i:Int) : Int
requires acc(loc(a, i).val)
{
    loc(a, i).val
}

method m1(a:IArray, index:Int, v:Int)
requires index >= 0 && index < len(a)
requires forall i:Int :: i >= 0 && i < len(a) ==> acc(loc(a, i).val)
ensures forall i:Int :: i >= 0 && i < len(a) ==> acc(loc(a, i).val)
ensures loc(a, index).val == old(loc(a, index).val) + v
{
    loc(a, index).val := read(a, index) + v
}

/* Encoding of arrays */

field val: Int

domain IArray {
  function loc(a: IArray, i: Int): Ref
  function len(a: IArray): Int

  axiom length_nonneg {
    forall a: IArray :: len(a) >= 0
  }
}
\end{lstlisting}
\caption[silver]
   {example of a silver program}
\label{rec}
\end{figure}

\subsection{Unbounded Heap Structures}
To represetn unbounded heap structures, there are currently three concepts used: Predicates, Magic Wands and Quantified Fields Permissions. Where Predicates allows to define unbounded structures recursively, magic wands allow us to keep track of heap structures during their traversal. Quantified Field Permissions additionally allow to express unbounded structures which ware not recursively defined.

\subsubsection{Recursive Predicates}
"Predicates can be used both to abstract over conctrete assertions and to write recursive specifications of heap data structures."

Recursive Predicates\cite{parkinson2005separation} are typically used as part of separation logic to specify linked data structures such as lists and trees. Its definition consists of a name,  list of formal parameters and a body. 
Since predicates can be recursive, for example in case of the example in figure \ref{rec}, and the predicate could potentially be unrolled endlessly, Silver introduces a predicate instance separately from its body.
The permission of the predicate may be exchanged for its body via \textit{unfold}, whereas \textit{fold} exchanges the properties of the body for the permission of the predicate. Additionally, \textit{unfolding} additionally allows to temporarily unfold a predicate.

"until and unfold is applied, predicate instances are treated as opaque, in the sense that the permissons and logical facts are entailed by their definitions are not directly availabe to the verifier. unfold, fold: ghost operations"

%example recursive
\begin{figure}[h]
  \centering
\begin{lstlisting}
field val: Int
field next:Ref

predicate list(r:Ref)
{
    acc(r.val) && acc(r.next) && (r.next != null ==> list(r.next))
}
\end{lstlisting}
\caption[recursive predicate]
   {example of a recursive predicate definition}
\label{rec}
\end{figure}


%example
\begin{figure}[h]
  \centering
\begin{lstlisting}
field f: Int

predicate pred(r:Ref)
{
    acc(r.f)
}

method m1(r:Ref)
requires acc(pred(r))
ensures acc(pred(r))
ensures unfolding pred(r) in r.f == 0
{

    unfold pred(r)
    r.f := 0
    fold pred(r)
}
\end{lstlisting}
\caption[predicate example]
   {Simple predicate example. By unfolding the predicate in line 14, we loose the access right to the predicate \textit{pred(r)} and gain the access rights to \textit{r.f}. This allows us to write to the field. By folding the predicate again, we regain the access rights to the predicate, which allows us no exhale the predicate in line 10. Unfolding temporarily unfolds the predicate \textit{pred(r)}, after which we obtain the permission to read the field \textit{r.f}, and also the value of that field. As a result, the assertion \textit{r.f == 0} should always evaluate to true.}
\end{figure}

\subsubsection{Magic Wands}
A magic wand A --* B is a binary connective, which allows that given left-hand assertion A is satisfied in the current state, can be exchanged for the right-hand assertion B. It is a concept which was already mentioned in the first papers of separation logic\cite{reynolds2002separation} and can be used to keep track of partial data structures during a traversal.

A magic wand instance is stored using its so-called \textit{footprint}, which is a subset of the current state that satisfies the wand's semantics. The footprint itself is not directly determined by its definition. The strategy of selecting a footprint in Viper is to include all permision required by the wands right-hand side, which we cannot prove to be provided by the wand's left-hand side\cite{magicwand}.

As for the concept for predicates, automatically exchanging the assertions of a magic wand is proven to be undecidable \cite{brochenin2008almighty}. As a consequence, Viper treats an instance of a magic wand as opaque. Exchaning the left-hand side of a magic wand with its right-hand side can be done with the ghost operation \textit{apply}. It is desugared to the following statements:

\vbox{
\begin{longtable}{ p{0.9\textwidth} } 
\( apply A --*B \mapsto \) \\ 
\ident \(exhale A--*B \)\\
\ident \(exhale A\)\\
\ident \(inhale B\)\\
\end{longtable}
}

A second ghost operation \textit{package} calculates a suitable footprint, which is then exchanged for a new wand instance.

%example...

%Quantified Field Permissions
\subsubsection{Quantified Field Permissions}
\label{qf}
The generalisation of quantified permissions as defined before is building on top of the concept presented for quantified field permissions of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}.
It defines a new definition for quantified heap chunks and an approach to inhale and exhale quantified field permissions.

%Quantified Field Chunk
\paragraph{Quantified Field Chunk}
Heap chunks are generalised to denote permission to an unbounded number of locations simultaneously.
In order to avoid an existential query in making a quantified permission chunk depending on the variable of the original forall expression, an inverse function is introduced, which maps a location to the initial value of the variable. To guarantee the existence of an inverse function, it is necessary that the expression denoting the receiver must be injective, which does however not restrict the data structures that can be handled by this approach as long as correctly specified.This allows us to define a quantified permission chunk of the form r.f -> [v(r), p(r)], where r represents the quantified receiver, p(r) an expression denoting the permission amount and v(r) a value map used to hold the values of the locations.
General form: r.f -> [v(r), c(inv(r)) ? p(inv(r)) : 0)]

%Inhale
\paragraph{Inhale}
Given a symbolic heap, a path condition and a quantified field permission, inhaling returns an updated heap and path conditions.
Inhaling generates a new quantified heap chunks  r.f -> [v(r), c(inv(r)) ? p(inv(r)) : 0)] after evaluating the condition, receiver expression and permission expression, as well as introducing the inverse function inv and a fresh value map v(r).
The inverse function is only defined if the given condition c(x) or c(inv(r)) holds.The definition adds two quantified conditions to the path condition starting from a general location and the original variable types variable.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{e}(y)) := eval(h_0, \pi_0, e_y)) \)\\
\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_0, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow Ref\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall r: Ref \cdot c(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot c(e(x))  \Rightarrow e^{-1}(\underline{e}(r)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Inhaling a Quantified Field Permission]
   {Symbolic execution rules for inhaling a quantified field permission. The function \textbf{eval} is used to evaluate an expression in the given symbolic state. This may update the path variables, and yields the resulting symbolic expression. The symbolic value of the evaluated condition is added temporarily to the path condition for the evaluation of e(y) and p(y). These expressions may not be considered well-formed otherwise.}
\label{qfInhale}
\end{longtable}

%injectivity

%Exhale
\paragraph{Exhale}
Exhaling again evaluates the condition, receiver expression and permission expression, checks the injectivity of the receiver expression, introduces its inverse function and proceeds to remove the permission from the heap.
The removing is done by walking through all quantified field chunks with the same field f, removing permissions greedily or fails if there is not enough permission. Updating chunks is expressed via point-wise defined functions defining the permission amounts.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check} \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land \underline{e}(y_1) = \underline{e}(y_2) \Rightarrow  y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var} h_1 :=  remove(h_0, \pi_6, f, (\lambda r \cdot \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified field permission. Eval. Check...}
\label{qfExhale}
\end{longtable}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all chunks in given state for field \(f\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_f := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(r.f  \mapsto [v_i(r), q_i(r)] \in h_f\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda r \cdot min(q_i(r), q_{needed}(r))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda r\cdot q_{needed}(r) - q_{current}(r)) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_f := h'_f \cup \{r.f \mapsto [v_i(r), (q_i(r) - q_{current}(r))] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(r) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_f)  \cup h'_f \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Field Permission]
   {Symbolic execution rules for removing a quantified field permission. Eval. Check...}
\end{figure}

%summarise
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{summarise}\(\ (h_0, f) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for field \(f\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \(def := \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \(perm := \lambda r \cdot 0\) \\
\ident \textbf{foreach } \((r.f \mapsto [v_i(r), q_i(r)]) \in h_f \) \textbf{do:} \\
\ident \ident \(def := def \cup \{ \forall r \cdot 0 < q_i(r)  \Rightarrow v(r) = v_i(r) \} \) \\
\ident \ident \(perm := \lambda r \cdots (perm(r) + q_i(r)) \) \\
\ident \textbf{return} \((v, def, perm)\) \\
\}\\ \hline
\end{tabularx}
\caption[Summarise Quantified Field Permissions]
   {Symbolic execution rules for summarizing quantified field permissions. Eval. Check...}
\end{figure}


\section{Quantified Predicate Permissions}
\label{qpp}
In this section we present an adaption of the mentioned solution of quantified field permissions support to allow the support of quantified predicate permissions. 
As the general form we consider the adaption of the canonical form presented for quantified field permissions: 
\begin{equation}
 \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(pred(e_1 (x),…,e_n (x)), p(x)), 
\end{equation}
where \(c(x)\) is a boolean expression,\(\ e_i(x)\) denotes the expression conforming to the type of the ith arguments of the predicate \textit{pred} and \(p(x)\) permission expression.

Introducing this new form allows us to express permission to more complex structures such as a set of lists.

\subsection{General Approach}
%Technical Challenges of it
To explain the adaption needed for the implementation, we again discuss the answers to the following questions:
\begin{enumerate}
\item How to model the program state, including permissions and values?
\item How to check for a permission in a state?
\item How to add and remove permissions to and from a state?
\item How to evaluate (heap-dependent) expressions in a state?
\item When to preserve (frame) an expression's value across heap changes?
\end{enumerate}
%Example

The first problem is handled in section \ref{shr}, the second and third in section \ref{qpp}. the fourth and fifth question is answered  in section \ref{qppVals}. 

\subsection{Symbolic Heap Representation} \label{shr}
In order to reason about quantified predicate permissions, it is necessary to define a symbolic heap representation for a potentially unbound set of predicates simultaneously. In the previous design, the quantified field heap chunk is defined by the field name, where permission and value are defined using a general location reference \(r\).
For quantified predicate chunk we use the predicate instead of the field as identification, where we use a set of general arguments to express permission and values. The general form of such a heap chunk conforms to:
\begin{equation}
	\mathbf{pred}(\mathrm{arg_1, ..., arg_n})\mapsto [v(\mathrm{arg_1, ..., arg_n}), p(\mathrm{arg_1, ..., arg_n}))],
\end{equation}
where \textit{v} represents a value map, where the values represent the snapshot of a predicate instantiation.

In order to translate the given permission to that form, we need to adapt the definition of the inverse function presented in section \ref{qf}. As before, the inverse function is used to get from a general location to the variable used in the original quantified permission expression. For a field, that location was expressed by the neutral location \(r\). For predicates, the general location is expressed by the predicate name and its arguments, \textit{pred}\((arg_1, \dots, arg_n)\). As soon as a single argument of two predicate location differs, it is not the same location.
A new inverse function is defined for each expression. Since the predicate name is however independent of the quantifier variable, it is not needed to define the inverse function. The adapted definition of the inverse function is only depending on the arguments themselves.

As before the new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier given the arguments of the predicate. The adapted inverse function is defined as:\\

\begin{tabularx}{1\textwidth}{ X}
\textbf{function }\(inv(a_1:A_1, \dots, a_n:A_n): T\) \\
\(\forall \ x:T :: c(x) \Rightarrow inv(e_1 (x),…,e_n (x))==x \) \\
\( \forall \ a_1:A_1,\dots, a_n:A_n ::  c(inv(a_1, …,a_n )) \Rightarrow e_i (inv(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}\\

The inverse function is, as before, a partial function defined only for the values where the condition of the original quantifier applies. For these cases, the inverse of the arguments defined by the argument expressions should be equal to the original value of the quantifier. Starting from arbitrary arguments, given that the inverse of these arguments satisfies the condition, each argument should be equal to its argument expression if evaluated with the inverse of all arguments.

Similar as for quantified field permissions, we have to restrict the allowed expression terms as a result to guarantee the existence of the defined inverse function. The location expressed by the quantifier has to be injective. Since the predicate name remains unchanged, this is guaranteed as long as at least one argument expression is guaranteed to be unequal for two locations of the quantifier. This property can be expressed by the following equation:\\

\begin{tabularx}{1\textwidth}{ X}
 \(\forall x_1:T, x_2: T :: c(x_1) \land c(x_2) \land (e_1(x_1) = e_1(x_2)) \land \dots \land  (e_n(x_1) = e_n(x_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(x_1 = x_2\) \\
\end{tabularx}\\

\subsection{Treatment of Permissions} \label{qpp}
Given the new definition of quantified predicate heap chunks, we need redefine the \(inhale\) and \(exhale\) operations for quantified predicate permissions.

\subsubsection{Inhaling}
The adapted symbolic execution rules for a inhaling a quantified permission can be seen in figure \ref{qpInhale}. It differs in the definition of the inverse function, as well as the values of the value map.

As before, inhaling a quantified predicate permission updates a given state and returns an updated heap and path condition. Similarly the quantified field expression, the condition, argument expressions and permission expression are evaluated as a first step.

The inverse function is introduced analogous to a quantified field permission and further defined by adding two constraints to the path condition, defining its properties. The the cardinality of the inverse function may vary for different predicates, but is identical for the same predicate.

As a last step we introduce a value map, which is later used to keep track of the snapshot of predicate instantiations. These values are used during an unfold or unfolding. On introduction, all snapshots are unknown.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \)  \textbf{forall } \(x:T :: c(x) \Rightarrow \)  \textbf{acc} (\textit{pred}  \( (e_1 (x),…,e_n (x)), p(x)) \)  \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}(y)) := eval(h_0, \pi_{2_{n-1}}, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident \textit{/* Introduce value map */}\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Inhaling a Quantified Predicate Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission. They refer to the rules for inhaling quantified field permissions as in figure \ref{qfInhale}. The declaration of the inverse function is updated as described before. The inverse function takes a set of predicate arguments and returns the value of the variable originally expressed in the quantifier. The type of the value map corresponds to the snapshot type of the predicate.}
\label{qpInhale}
\end{figure}

\subsubsection{Exhaling}
The adaptations necessary for exhaling quantified predicate permissions again include an update for evaluating the argument expressions, as well as the introduction of the inverse function as defined for inhaling. Additionally, the injectivity check needs to be adapted as defined in the previous section. The new rules are defined in figure \ref{qpExhale}.

After evaluating the expressions denoted by the quantified predicate permission, we check the injectivity before introducing the inverse functions as defined in the inhaling. The check passes if for any two variables satisfying the initial condition,  at least one argument expression is evaluated to a different symbolic value.

The definition of removing a permission amount from a quantified expression does not need to be changed except for the filtering of the quantified chunks. After that, we again iterate through these chunks, taking permission greedily. If there is not enough permission available, we raise. The updated definition can be seen in figure \ref{qpRemove}.

%exhale
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission.} %expand description: check, remove....
\label{qpExhale}
\end{figure}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Predicate Permission]
   {Symbolic execution rules for removing a quantified predicate permission. Eval. Check...}
\label{qpRemove}
\end{figure}

\subsection{Treatment of Symbolic Values} \label{qppVals}
Predicates may modify symbolic values while unfolding and folding predicates. When working with quantified predicates, the unfold and fold operations need to be adapted. 


Unfolding a predicate

%summarise
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{summarise}\(\ (h_0, pred) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for predicate \(pred\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \(def := \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \(perm := \lambda r \cdot 0\) \\
\ident \textbf{foreach } \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:}\\
\ident \ident \(def := def \cup \{ \forall a_1, \dots, a_n \cdot 0 < q_i(a_1, \dots, a_n)  \Rightarrow v(a_1, \dots, a_n) = v_i(a_1, \dots, a_n) \} \) \\
\ident \ident \(perm := \lambda a_1, \dots, a_n \cdots (perm(a_1, \dots, a_n) + q_i(a_1, \dots, a_n)) \) \\
\ident \textbf{return} \((v, def, perm)\) \\
\}\\ \hline
\end{tabularx}
\caption[Summarise Quantified Field Permissions]
   {Symbolic execution rules for summarsing quantified predicate permissions. Eval. Check...}
\end{figure}

%overview
\subsubsection{Fold} 
\label{qFold}
As mentioned in the background, folding a predicate exchanges the permission of the body with the permission to the predicate which is being folded. As a consequence it creates a new predicate chunk. The predicate chunk contains the values of the permissions held by the predicate body previous to folding it, which is called a snapshot of the predicate.

When folding a quantified predicate, we first generate a snapshot based on the current heap. The exhale checks that there is enough permission to the predicate body by summarising the given quantified chunk and removes the permission amount required. 
Inhaling the predicate provides a new predicate chunk, where the value map holds the snapshot previously generated for the predicate folded.

The exact operations can be seen in figure \ref{qFold}.
%fold
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{fold}\(\ (h_0, \pi_0, pred(e_1, \dots, e_n))\) \{\\
\ident \textit{/* evaluate arguments */} \\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}) := eval(h_0, \pi_0, e_1)) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}) := eval(h_0, \pi_0, e_n)) \)\\
\\
\ident \textit{/* generating the predicate's snap value */} \\
\ident \textbf{var } snapshot \(:=\) \textit{generateSnap}\((h_0, pred, (\underline{e_1}, \dots, \underline{e_n}))\)\\
\\
\ident \textbf{var } \((h_1, \pi_{n+1}) :=\) exhale\((h_0, \pi_n, snapshot) \) \\
\ident \textbf{var } \((h_2, \pi_{n+2}) :=\) inhale\((h_1, \pi_{n+1}, pred(e_1, \dots, e_n)\) \\
\ident \textbf{return} \( (h_2, \pi_{n+2}) \)  \\
\}\\ \hline
\end{tabularx}
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for folding a quantified predicate} %expand description: check, remove....
\label{qFold}
\end{figure}

\subsubsection{Unfold} 
\label{qUnfold}
Unfolding a predicate corresponds to evaluating the predicate snapshot, exhaling a single predicate, after which we inhale the body of the predicate. Figure \ref{qUnfold}


%unfold
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{unfold}\(\ (h_0, \pi_0, pred(e_1, \dots, e_n))\) \{\\
\ident \textit{/* evaluate arguments */} \\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}) := eval(h_0, \pi_0, e_1)) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}) := eval(h_0, \pi_0, e_n)) \)\\
\\
\ident \textit{/* read the predicate's snap value */} \\
\ident \textbf{var } \((v, \) \textit{def}, \textit{perm}\() :=\) \textit{summarise} \((h_0, pred)\) \\
\ident \textbf{var } snapshot \(:=\) \( v (\underline{e_1}, \dots, \underline{e_n})\)\\
\\
\ident \textbf{var } \((h_1, \pi_{n+1}) :=\) exhale\((h_0, \pi_n, pred(e_1, \dots, e_n)\) \\
\ident \textbf{var } \((h_2, \pi_{n+2}) :=\) inhale\((h_1, \pi_{n+1}, snapshot)\) \\
\ident \textbf{return} \( (h_2, \pi_{n+2}) \)  \\
\}\\ \hline
\end{tabularx}
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for the fold operation} %expand description: check, remove....
\label{qUnfold}
\end{figure}

\subsection{Unfolding}
Unfolding is desugared as before, by using the unfold definition of  \ref{qUnfold} on the predicate, evaluating the expression e and finally folding the predicate as described in \ref{qFold}.

%silicon
\subsection{Silicon}
%general introduction.

%precomputing 
As for quantified field permission, Silicon analyses the program given, creating a list of quantified predicates. Additionally, it also precomputes a set of predicate arguments used to express the general predicate locations in quantified heap chunks and assertions generated, as well as a general snapshot.

%chunk definition
If a predicate is quantified, both single predicates and quantified predicates are represented by a quantified predicate chunk. As defined in \ref{shr}, a quantified predicate chunk consists of a predicate name, the set of general locations, a value function, a permission term. Additionally, it also holds the inverse function, which...? what is it used for?

A single predicate is restricted to the following form:\\

\begin{equation}
	\mathbf{pred}(\mathrm{a_1, ..., a_n})\mapsto [s(\mathrm{a_1, ..., a_n}), p((\mathrm{a_1} == \underline{a_1}, \dots, \mathrm{a_n} == \underline{a_n}) ? \underline{p}]
\end{equation}

%inhale && exhale
The adaption for inhaling and exhaling are build on the approach presented in section \ref{qpp}.

%triggering

%silicon
\subsection{Carbon}
Carbon, in contrast to Silicon, models the heap using Masks. The implementation for quantified fields is based on translating the statement and its properties into a number of forall expressions in Boogie. Quantified field chunks are not defined.

Apart from inhaling and exhaling quantified field permissions, there are no changes in the translation. There is no adaption that need to be done for reading or writing a field.

\subsubsection{Inhale}
Inhaling consists of the following steps:

Inhaling a quantified field permission consists of the following steps:
\begin{itemize}
\item Define the inverse function by assuming the two inverse functions definitions as defined before
\item Assume that receiver references where the conditions applies to true, are non null
\item Assume that the permission denoted is nonnegative for all fields
\item Assume that the receiver expression is injectiive
\item Assume that for all locations where the condition evaluates to true, gains the defined permission
\item Assume that all independent locations, which include all fields f where the condition evaluates to false, all other fields, as well as magic wands and predicate locations, have the same value as before.
\end{itemize}

%carbon inhale quantified field
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x)) \) \{\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow A_1, \dots, A_n\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\}\\ \hline
\end{tabularx}
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for the fold operation} %expand description: check, remove....
\label{qUnfold}
\end{figure}

\subsubsection{exhale}

\begin{itemize}
\item Inverse Assumptions
\item non null assumption
\item permission nonnegative for all fields
\item assume injectiivty
\item define permission
\item independent locations
\end{itemize}

\subsubsection{inhale}

%carbon inhale quantified field
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),\dots,e_n (x)), p(x)) \) \{\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow A_1, \dots, A_n\) \\
\ident \textbf{assume\ } \( \forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \textbf{assume } \( \forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident \textit{/* Injectivity Assumption */} \\
\ident \textbf{assume\ }\(\forall y_1, y_2\ \{pred(e_1(y_1), \dots, e_n(y_1)), pred(e_1(y_2), \dots, e_n(y_2))\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \land ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \) \\
\ident \ident \ident \ident \( \lor  (\underline{e_n}(y_1) \ne \underline{e_n}(y_2)) \Rightarrow y_1 = y_2\) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\} c(inv(a_1, \dots, a_n)) \Rightarrow perm(pred(a_1, \dots, a_n)) = \) \textbf{old} \(( perm(pred(a_1, \dots, a_n)))  + p(inv(a_1, \dots, a_n))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\}\ \neg c(inv(a_1, \dots, a_n)) \Rightarrow perm(pred(a_1, \dots, a_n)) = \) \textbf{old} \((perm(pred(a_1, \dots, a_n))) \)\\
\ident \textbf{assume\ } \(\forall o:Ref, f:Field :: \{tr\}\ (obj \ne null \land \neg isPredicateField(f) \land predicateId(f) != predicateId(pred)) \Rightarrow perm(o.f , a_n)) = \) \textbf{old} \((perm(o.f)) \)\\
\}\\ \hline
\end{tabularx}
\caption[carbon quantified predicate inhale]
   {Translating quantified predicate inhale operation} %expand description: check, remove....
\label{qpcInhale}
\end{figure}


%carbon exhale quantified field
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),\dots,e_n (x)), p(x)) \) \{\\
\ident \textit{/*wild card assumptions */} \\
\\
\ident \textit{/* permission positive */} \\
\\
\ident \textit{/* Injectivity Assertion */} \\
\ident \textbf{assert\ }\(\forall y_1, y_2\ \{pred(e_1(y_1), \dots, e_n(y_1)), pred(e_1(y_2), \dots, e_n(y_2))\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \land ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \) \\
\\
\ident \textit{/* Injectivity Assumption */} \\
\ident \textbf{assume\ }\(\forall y_1, y_2\ \{pred(e_1(y_1), \dots, e_n(y_1)), pred(e_1(y_2), \dots, e_n(y_2))\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \land ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \) \\
\ident \ident \ident \ident \( \lor  (\underline{e_n}(y_1) \ne \underline{e_n}(y_2)) \Rightarrow y_1 = y_2\) \\
\\
\ident \textit{/* sufficient permission assertion*/} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\} c(inv(a_1, \dots, a_n)) \Rightarrow perm(pred(a_1, \dots, a_n)) = \) \textbf{old} \(( perm(pred(a_1, \dots, a_n)))  + p(inv(a_1, \dots, a_n))\)\\
\\
\ident \textit{/* define updated permission */} \\
\\
\ident \textit{/* define independent permissions */} \\
\}\\ \hline
\end{tabularx}
\caption[carbon quantified predicate exhale]
   {Translating quantified predicate exhale operation} %expand description: check, remove....
\label{qpcExhale}
\end{figure}

%Quantified Magic Wands
\section{Quantified Magic Wands}
A representation of a Magic Wand\cite{magicwand} depends on the form of de wand definition and may have multiple arguments. As a consequence, the definition for inverse funcitons and injectivity are analogous to a quantified predicate permission.

%example

%Combinations of Quantifiers
\section{Combinations of Quantifiers}
Silver currently does not allow to merge pure and permission-based quantifiers, nor does it allow combinations of multiple quantified permissions. This can be circumvented by repeating the definitions prior to the quantified expression.
To decrease the code size for specifying the properties desired and support user-friendliness it would however be desirable to lift this restriction.

We consider adding the support of the following expressions:
\begin{equation}
\label{eq1}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))
\end{equation}
\begin{equation}
\label{eq2}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x)),
\end{equation}
where {\it trs} is a set of triggers and {\it c(x)} a boolean expression. The expression {\it e(x)} can be either pure or permission-based. In the second case it should be either of the expressions which were already supported before - a field permission, predicate permission or magic wand permission - or combination of these expressions. For the first newly introduced quantified expression, the sub-expressions \(e_1(x))\) and \(e_2(x)\) have to be injective, as should be \( e(x)\) in the second equation.

The first expression allows to combine two expressions on the right-hand side of the implication. The second expression  grants us the ability to refine a condition. Both are currently only allowed if they are entirely pure. An example using this new feature would be: 

\begin{lstlisting}
field f: Int
field g: Int

method m1(r:Ref, xs: Seq[Ref], b:Int)
requires forall x:Ref :: x in xs ==> (b ==> acc(x.f)) && (!b ==> acc(x.g))
ensures forall x:Ref :: x in xs ==> (b ==> acc(x.f)) && (!b ==> acc(x.g))
ensures b? (x.f == 2) : (x.g == 3)
{
    if (b)
    {
        x.f := 2
    }
    else
    {
        x.g := 3
    }
}
\end{lstlisting}

Other combinations using boolean expressions are currently not considered unless they are part of a boolean expression. This is due to the fact, that Silver does not supported them permission-based expressions as well.

\subsection{Conjunction}
As a first solution we propose to adapt the symbolic execution rules to handle these cases.
If the entire expression is fully pure, this is handled as previously.The sub-expressions of the combinations may be depending on each other. An example for this would be: 
\begin{equation}
\label{eq1}
	\mathbf{forall} \; x:T :: \{\}\  x\ \mathrm{in \ Set} \{\dots\} \Rightarrow acc(x.f) \ \&\& \ (x.f > 0)
\end{equation}
As a consequence, both expressions have to be evaluated sequentially. 
Let's consider the case where both subexpressions denote a field permission. Due to the sequentiality constraint, we treat the first expression as before. We cannot generally reuse the inverse function and injectivity definition for the second expression as defined before. A adaption to the rules would therefore skip the evaluation of the condition, but essentially repeat all other steps for the second expression.
If one of the expressions is pure, we treat it independently as before.

As a second solution, we therefore propose to rewrite the given quantifiers to two quantifiers, so that the rewritten quantifiers allow us to reuse the symbolic execution rules presented: 
\begin{equation}
\begin{aligned}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))  \mapsto \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x)  \Rightarrow e_1(x)) \ \&\& \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x) \Rightarrow  e_1(x))
\end{aligned}
\end{equation}

As mentioned before, there is only a minimal advantage in adapting the symbolic rules due to the fact that the condition is evaluated multiple times. The value could also be cached. The triggers are passed along to both quantifiers.

\subsection{Refining}
Similar to the solution presented for the conjunction of expressions within a quantifier, besides having the option of adapting the symbolic execution rules for the previously shown solutions, we can desugare the expression to the already supported form by using its logical equal:
\begin{equation}
\begin{aligned}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x))  \mapsto \\
	\mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x))
\end{aligned}
\end{equation}

\subsection{Example}
The forall expression of the example is rewritten to the following way: \\

\begin{tabularx}{1\textwidth}{ X }
\(\mathbf{forall\ } x:Ref :: x\ in\ xs \Rightarrow (b \Rightarrow  acc(x.f)) \:\&\&\ (!b \Rightarrow acc(x.g)) \mapsto \) \\
\((\mathbf{forall\ } x:Ref :: x\ in\ xs \Rightarrow (b \Rightarrow  acc(x.f))) \:\&\&\ (\mathbf{forall\ } x:Ref :: x\ in\ xs \Rightarrow (!b \Rightarrow acc(x.g)) \mapsto \) \\
\((\mathbf{forall\ } x:Ref :: (x\ in\ xs)  \:\&\&\ b \Rightarrow acc(x.f)) \:\&\&\ (\mathbf{forall\ } x:Ref :: (x\ in\ xs)  \:\&\&\ !b \Rightarrow  acc(x.g)) \) \\
\end{tabularx}


\subsection{Implementation}
The implementation for supporting the combinations presented uses the rewriting rules mentioned above. The desugaring takes place in Silver. Both Carbon and Silicon accept the same program with the already rewritten expressions.

%Nested Quantifiers
\section{Nested Quantifiers}
%Why nested quantifiers?
In this section we present another adaption removing the restriction that a quantified permission may depend on one variable only. After applying the rewriting rules given in section \ref{rewriting}, there are two forms of nested quantifiers which are desirable to support.

In the first structure, all variables are defined at once, allowing condition and expression to depend on all of them:\\

\begin{tabularx}{1\textwidth}{ X }
	\( \mathbf{forall} \; x_1:T_1, \dots, x_n: T_n ::  \{trs\}\ c(x_1, \dots, x_n) \Rightarrow \) \\
	\(e(x_1,  \dots, x_n)\)
\end{tabularx}\\

The expression \(e(x_1,  \dots, x_n)\) stands for any unquantified permission where we presented a quantified solution in the previous chapters, Pure quantifiers of this form are already supported in Viper. For the support of this new quantified expression we present a new generalisation of the previously shown algorithms in section \ref{generalN}.\\

The second structure represents a truly nested quantifier, where on the right-hand side of the implication. The following formula represents such a form with two quantifiers:\\

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\end{tabularx}\\

Here the expression \(e(x_1, x_2)\) can, as mentioned before, be any permission expression introduced or another quantified expression. As a solution we present a new rewriting rule in section \ref{rewritesN}.

Both formulas allow us to define more complex quantifiers, for example access rights to a matrix, without resorting to reformulate them 

\subsection{Generalisation for Nested Quantified Permissions}
\label{generalN}




\subsubsection{Symbolic Heap Representation} \label{shr}
By changing the number of variables a quantifier depends on, we do not need to change the design of the heap chunks itself. Both the types and arguments do not change. The way to translate an argument to its neutral form, however, does. We need a way to retrieve the original variables using inverse functions. In order to do that, we introduce \(n\) inverse functions, which each map from a general location to the value of one variable.

In order to translate the given permission to that form, we need to adapt the definition of inverse function. The new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier given the arguments of the predicate. The adapted inverse functions for quantified field and predicate permissions can be seen in figure \ref{nInv}.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{ X}
\textit{/* Nested Field Quantifie */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),…,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_n(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_n(a_1,\dots, a_n )) = a_i \) \\
\\
\textit{/* Nested Predicate Quantifier */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),…,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_n(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_n(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}
\caption[Nested Inverse Functions]
   {Inverse Function definitions for nested quantifiers for quantified field and predicate permissions, for all inverse functions \( i\), where \( 1 \leq  i \leq  n \).}
\label{nInv}
\end{figure}

Using these inverse functions also enforces us to restrict the allowed expressions for nested quantifiers. \(e(x)\) has to be injective. These new conditions are shown in figure.


\subsubsection{Treatement of Permissions} \label{qpp}
With the new quantified predicate heap chunks defined above, we redefine \(inhale\) and \(exhale\) operations for quantified predicate permissions.

Inhaling a nested quantified permission is now done using the inverse definition shown before. The newly generated heap chunk uses the inverse functions to whether the conditions of the general locations are met, as well as the determination of the permission amount itself.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x)) \) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_1}(y)) := eval(h_0, \pi_0, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow A_1, \dots, A_n\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Inhaling a Quantified Field Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission.}
\label{qpnInhale}
\end{figure}

Exhaling a nested quantified permission is done analogously. The check for the inverse function is also altered accordingly.

%exhale
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission.} %expand description: check, remove....
\label{qpnExhale}
\end{figure}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Field Permission]
   {Symbolic execution rules for removing a quantified field permission. Eval. Check...}
\label{qpnRemove}
\end{figure}

The definition of removing a permission amount from a quantified expression does not need to be changed except for the filtering of the quantified chunks. After that, we again iterate through these chunks, taking permission greedily, and raising an error if not enough permission is available. The updated definition can be seen in figure %\ref{qpRemove}.

\subsection{Treatment of Symbolic Values} \label{qppVals}
The predicate snapshot is used during unfold, fold and unfolding, where unfold corresponds to a field read and fold to field write in the context of a quantified field permission.


\subsection{Rewriting Rules for Nested Quantified Permissions}
\label{rewritesN}

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\\
    \( \longmapsto\)\\
\\
      \(\mathbf{forall \ }  x_1:T_1, \dots x_{n+1}:T_{n+1} ::  \{trs_1 \times trs_2\}\  \) \\ 
\ident \ident \ident \(( c_1(x_1, \dots, x_n) \:\&\&\:   \ c_2(x_1, \dots, x_{n+1}) )  \Rightarrow  e(x_1, \dots, x_{n+1}))\) \\
\end{tabularx}\\

\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}