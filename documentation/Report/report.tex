\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{longtable}
\usepackage{silver}

\lstset{
         numbers=left,
 }

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
  % basicstyle={\small\fontfamily{cmtt}\selectfont}
  % basicstyle={\ttfamily\selectfont\footnotesize},
  % commentstyle={\ttfamily\selectfont\footnotesize},
  tabsize=2,
  mathescape=true,
  language=silver
  % basicstyle=\ttfamily
}

\begin{document}
\pagenumbering{gobble}
\clearpage
\newcommand*{\ident}{\hspace*{0.5cm}}
\newcommand{\wand}{\ensuremath{\mathbin{-\!\!*}}}

\maketitle
\newpage

\clearpage
\pagenumbering{Roman}
\tableofcontents
\newpage
\clearpage
\pagenumbering{arabic}% Arabic page numbers (and reset to 1)
\section{Abstract}
Viper supports a quantified field permission of the form \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\). The quantifier may only depend on one variable and express permissions to a set of fields. Viper includes of two verifiers. Carbon is based on verification condition generation, whereas Silicon is based symbolic execution. In this report, we present approaches for both types of verifiers to generalise the supported quantified permissions. These approaches adapt the algorithm presented for quantified field permissions to quantified predicate and magic wands permissions, as well as nested quantifiers. We also present rewriting rules for combining pure and permission-based quantifiers.
We implemented both quantified predicate permissions and combinations of quantifiers in Carbon and Silicon.

\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs as shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} associate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a random access pattern in an array.

The paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Viper handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express point-wise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a Boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adaption of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

The next section presents an overview to Viper, including the approach integrated for quantified permissions. Section \ref{genField} presents some minor adaptions for the treatment of quantified field permissions, including the support of user-given triggers in Carbon. The adapted approach for quantified predicate permissions is introduced in section \ref{qp}.

%to be continued

\section{Background}
\label{background}
%Permissions in general
In this chapter we give an overview of the theory needed to understand the proposed generalisation of quantified permissions. The generalisation is intended as an extension to the support of quantified fields already integrated in Viper\cite{viper}\cite{viper2014}.

Viper is a verification infrastructure for permission-based reasoning and enables the development of program verifiers based on permission logics. It is designed to facilitate the implementation of verification techniques for programs, allowing developers to focus on the encoding of higher-level language features into its intermediate verification language. It includes an intermediate verification language, two automatic back-end verifiers \textit{Carbon} and \textit{Silicon}, as well as several front-ends translating other programming languages to Viper for verification. For the generalisation we allow new quantified expressions in Viper. To support the verification of these, we adapted both Carbon and Silicon. 

\textit{Carbon}  is based on verification condition generation. It translates the given Viper program to Boogie\cite{leino2008boogie}, which proves the generated code.
In Carbon, the state is modelled by maps representing the heap and permissions held.

\textit{Silicon} is based on the SMT solver Z3\cite{de2008z3} and Smallfoot-style Symbolic Execution\cite{berdine2005smallfoot}. The symbolic state is stored in heap chunks, holding permission and values for specific locations, and path conditions, which represent the properties obtained while evaluating or executing commands.

A Viper program consists of global declaration called fields, predicates, functions, methods, and custom domains. To represent unbounded heap structures, Viper supports the following concepts: Predicates, Magic Wands and Quantified Field Permissions.

%fields, methods, functions, predicates, custom domains.
\subsection{Permissions}
Permission logics were designed to define which locations of a heap are accessible. Viper works with fractional permissions with values between 0 and 1. Any permission greater than 0 grants read access, whereas 1 denotes full permission, which additionally allows write access to a location. 
In Viper, there are various constructs for representing permission. The one most used is the accessibility predicate acc\((e_1.f, e_2)\), denoting permission to a field location \textit{f} of the reference denoted by \(e_1\). The permission amount is expressed by \(e_2\). If the permission amount is omitted, the permission amount defaults to full permission.

\subsection{Program State}
The program state of Viper includes the current permissions held, as well as the assignments to program variables. The state can be manipulated by assertions, which may only depend on locations with permission. The process of verifying certain properties and updating the state during the execution of expressions can be reduced to inhaling and exhaling assertions. Inhaling is equal to adding the designated permission amount if the expression is represents a permission (e.g. acc\((e.f)\), or assuming a property if the assertion is pure. Exhaling translates to removing permission or asserting the properties specified. If the permission to a location is lost, we also lose information about its value.
%better specified?
Carbon uses maps to describe the heap and permissions held. 

In Silicon, the state representation includes a set of heap chunks and path conditions.

\subsection{Types and Domains}
The built-in primitive types of Viper consist of integers (Int), Boolean expressions (Bool), references (Ref) and permissions (Perm). Additionally,  polymorphic sequences such as Seq[T] and sets Set[T] are included. Domains further allow the definition of custom domain types, which may include axioms and functions to define their properties.

\subsection{Fields}
Fields are globally defined and have a designated type. On declaration, the field exists for all references. In order to read a field value, a permission amount greater than 0 is necessary. When writing to a field, full permission is required.

\subsection{Methods: }
Methods consist of a name, arguments, pre- and postconditions, as well as a method body. The preconditions must include sufficient permissions to allow all heap dereferences used in the method body. During verification, the verifiers inhale the preconditions and try to prove the postconditions after the execution of the body. If a method call is executed, the called method's precondition is exhaled. Subsequently, we gain the information defined by the postcondition by inhaling.

\subsection{Functions: }
Similarly to methods, functions consist of a name, preconditions, postconditions and optionally a body. Contrary to methods, the expressions within the body are restricted and must be pure. They may be used in assertions, as well as in axiom definition if the function is defined inside a domain.

\subsection{Recursive Predicates}
%"Predicates can be used both to abstract over concrete assertions and to write recursive specifications of heap data structures."

Recursive Predicates\cite{parkinson2005separation} are typically used to specify linked data structures such as lists and trees. A predicate definition consists of a name,  list of formal parameters and a body. 
Since predicates can be recursive, as in figure \ref{recursivePredicate}, and the predicate could potentially be unrolled endlessly, Viper treats predicate instances as opaque. Permissions and the logical facts entailed by its body are not directly available to the verifier. We use ghost operations to obtain the logical facts from a predicate instance and vice versa.
A predicate instance may be exchanged for its body via \textit{unfold}, whereas \textit{fold} exchanges the properties of the body for an instance of the predicate. Additionally, \textit{unfolding} additionally allows to temporarily unfold a predicate for a specified expression. An example using these ghost operations can be found in figure \ref{predicateExample}.

%example recursive
\begin{figure}[h]
  \centering
\begin{lstlisting}
field val: Int
field next:Ref

predicate list(r:Ref)
{
    acc(r.val) && acc(r.next) && (r.next != null ==> list(r.next))
}
\end{lstlisting}
\caption[recursive predicate]
   {example of a recursive predicate definition}
\label{recursivePredicate}
\end{figure}


%example
\begin{figure}[h]
  \centering
\begin{lstlisting}
field f: Int

predicate pred(r:Ref)
{
    acc(r.f)
}

method m1(r:Ref)
requires acc(pred(r))
ensures acc(pred(r))
ensures unfolding pred(r) in r.f == 0
{

    unfold pred(r)
    r.f := 0
    fold pred(r)
}
\end{lstlisting}
\caption[predicate example]
   {Simple predicate example. By unfolding the predicate in line 14, we lose the access right to the predicate instance \textit{pred(r)} and gain the access rights to the field \textit{r.f}. This allows us to write to the field . By folding the predicate again, we regain the access rights to the predicate, which allows us no exhale the predicate in line 10. Unfolding temporarily unfolds the predicate \textit{pred(r)}, after which we obtain the permission to read the field \textit{r.f}, and also the value of that field. As a result, the assertion \textit{r.f == 0} evaluates to true.}
\label{predicateExample}
\end{figure}

\subsection{Magic Wands}
A magic wand A \(\wand\) B is a binary connective, which allows that given left-hand assertion A is satisfied in the current state, can be exchanged for the right-hand assertion B. It is a concept which was already mentioned in the first papers of separation logic\cite{reynolds2002separation} and can be used to keep track of partial data structures during a traversal.

A magic wand instance is stored using its so-called \textit{footprint}, which is a subset of the current state that satisfies the wand's semantics. The footprint itself is not directly determined by its definition. The strategy of selecting a footprint in Viper is to include all permission required by the wands right-hand side, which we cannot prove to be provided by the wand's left-hand side\cite{magicwand}.

As for the concept for predicates, automatically exchanging the assertions of a magic wand is proven to be undecidable \cite{brochenin2008almighty}. As a consequence, Viper treats an instance of a magic wand as opaque. Exchanging the left-hand side of a magic wand with its right-hand side can be done with the ghost operation \textit{apply}. It is desugared to the following statements:

\vbox{
\begin{longtable}{ p{1\textwidth} } 
\( apply A \wand B \mapsto \) \\ 
\ident \(exhale A \wand B \)\\
\ident \(exhale A\)\\
\ident \(inhale B\)\\
\end{longtable}
}

A second ghost operation \textit{package} calculates a suitable footprint, which is then exchanged for a new wand instance.

%Quantified Field Permissions
\subsection{Quantified Field Permissions}
\label{qf}
%In order to 
%\begin{enumerate}
%\item How to model the program state, including permissions and values?
%\item How to check for a permission in a state?
%\item How to add and remove permissions to and from a state?
%\item How to evaluate (heap-dependent) expressions in a state?
%\item When to preserve (frame) an expression's value across heap changes?
%\end{enumerate}


The implementation of the quantified field permissions support depends on the verifier used. We first summarise how quantified field permissions are supported in the verification generator Carbon, and then explain the approach for symbolic execution, as presented in the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}. 

The supported shape of quantified field permission expression is defined as:

\begin{equation}
\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))
\end{equation}

The Boolean expression \(c(x)\) denotes a condition, under which a set of fields, defined by the reference-typed expression \(e(x)\) and the field \(f\), gain the permission amount expressed in the permission-typed expression \(p(x)\).

\subsubsection{Verification Condition Generation and Quantified Field Permissions}
\label{cgqf}
Since field permissions are represented using maps, it is sufficient to introduce a new translation for inhaling and exhaling quantified field permissions. Reading or writing to a field is done as before. 

\paragraph{Inhaling a Quantified Field Permission: }
Inhaling a field permission \(x.f\) updates the permission map for the specified location denoted by \textbf{Mask}\((x, f)\) and assumes  that the reference pointing to the field is non-null. In order to frame the quantifier \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\), we create a new map at the beginning of the translation, which replaces the current map after completing the inhale operation. The permission amount of the new map needs to be defined for both updated and unaffected locations and has to be triggered when evaluating any field access. This is only possible by expressing the quantifier from the perspective of a neutral location. This neutral location is defined as \(r\) for all quantifiers, where \(r.f\) is the field access of field \(f\). 

In order to translate the quantified field permission, we introduce a inverse function \(e^{-1}\), which maps the locations to the corresponding value x of type \(T\). Using the inverse function we can check, whether a location is altered by the quantifier by evaluating the condition as \(c(e^{-1}(r))\). The gained permission is equal to \(p(e^{-1}(r))\). 
The introduction of the inverse function enforces, that the expression \(e(x)\) has to be injective. When inhaling a quantified field permission, the injectivity of \(e(x)\) is assumed along with the property, that all references affected by the quantifier are non-null.

The exact translation can be seen in table \ref{qfconditionInhale}.

%carbon inhale quantified field. Frame?
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x).f, p(x)) \) \{\\
\ident Let \textit{qpMask} be a new Mask\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{e(x)\}\ \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:Ref ::\{e^{-1}(r)\}\ c(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* all receiver is non-null */} \\
\ident \textbf{assume } \( \forall x:T ::\{\}\ \underline{c}(x)  \Rightarrow \underline{e}(x)) != null \) \\
\\
\ident \textit{/* assume e(x) is injective */} \\
\ident \textbf{assume\ }\(\forall y_1: T, y_2:T ::\{\}\ y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{qpMask(r, f)\}\ \{e^{-1}(r)\}\) \\
\ident  \ident \ident \ident \ident \(c(e(r)) \Rightarrow qpMask(r, f) = Mask(r.f) - Mask(e^{-1}(r), f)\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{ qpMask(r, f)\}\{ e^{-1}(r)\}\)\\
\ident  \ident \ident \ident \ident \( \ \neg c(e^{-1}(r)) \Rightarrow qpMask(r, f) = \) Mask \((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:Object, f_o:Field :: \{Mask(o, f) \}\ \{ qpMask(o, f)\}\) \\
\ident  \ident \ident \ident \ident \((f_o != f) \Rightarrow qpMask(o , f) = \) Mask \((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon quantified field inhale]
   {Translating quantified field inhale operation. The triggers are for the given forall expressions are included within curly brackets. For the expressions assuming non-null receivers and injectivity, there were no triggers defined. In our adaption of this approach, we included triggers for both assumptions. The updated translation can be seen in in figure \ref{qfconditionInhaleExtended}.}
\label{qfconditionInhale}
\end{longtable}

\paragraph{Exhaling a Quantified Field Permission: }
Exhaling a quantified field permission \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\), includes two checks. First, we assert that the expression \(e(x)\) is injective. Then, we check that we possess the permission needed for exhaling the permission for all locations. If both checks pass, we introduce the inverse function and express the permissions of the map analogous for inhaling a quantified field permission. 
The translation is displayed in table \ref{qfconditionExhale}.

%carbon exhale quantified field
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{exhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x), p(x)) \) \{\\
\ident Let \textit{qpMask} be a new Mask   \\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \underline{e} \(:= eval(e)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* assert e(x) is injective */} \\
\ident \textbf{assert\ }\(\forall y_1: T, y_2:T ::\{\}\  y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* sufficient permission */} \\
\ident \textbf{assert\ } \(\forall x:T ::\{\}\ c(x) \Rightarrow Mask(e(x), f) \geq \underline{p}(x)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{e(x)\}\  \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:Ref ::\{inv(r)\}\  c(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{qpMask(r, f)\}\ \{ inv(r)\}\) \\
\ident  \ident \ident \ident \ident  \(c(inv(r)) \Rightarrow qpMask(r, f) = Mask(r.f) - Mask(inv(r), f)\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{ qpMask(r, f)\}\ \{ inv(r)\}\) \\
\ident  \ident \ident \ident \ident  \(\neg c(inv(r)) \Rightarrow qpMask(r, f) = \) Mask \((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:Object, f_o:Field :: \{Mask(o, f) \}\ \{ qpMask(o, f)\}\) \\
\ident  \ident \ident \ident \ident \( (f_o != f) \Rightarrow qpMask(o , f) = \) Mask \((o,f) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon quantified field exhale]
   {Translating quantified field exhale operation. The missing triggers are added in the adapted translation, which is defined in table \ref{qfconditionExhaleExtended}.} %expand description: check, remove....
\label{qfconditionExhale}
\end{longtable}

\subsubsection{Symbolic Execution Rules for Quantified Field Permissions}
\label{seqfp}
The solution presented in  \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc} introduces a new type of heap chunk, new rules for inhaling and exhaling single and quantified field permissions, as well as for reading and writing these field values.

%Quantified Field Chunk
\paragraph{Quantified Field Chunk:}
The permission amount and value of a field is stored in the heap as a field chunk. A field chunk \((r.f) \mapsto [v, p]\) is a defined for a specific reference \(r\) and a field \(f\), which is mapped to the location value \(v\) and the permission amount \(p\). The value \(v\) has the same type as the field \(f\), whereas \(p\) is a permission. 

To support quantified field chunks, a new type of chunk needed to be defined, which can hold a potentially unbounded set of references and values. A straightforward implementation of the expression \(\mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) would result in an heap of the form  \((x, f) \mapsto [v(x), c(x) ? p(x) : 0)]\), where x is of type T. The new chunk is defined for all values of type T. The permission and value are depending on x. The value \(v\) is changed to a value map storing the known values of the set. In order to evaluate the permission or value of a location \(r.f\), we would be forced to check for each chunk, whether there exists an \(x\), where the \(e(x)\) evaluates to the reference \(r\).

To avoid this, the representation is adapted to the form \((r.f) \mapsto [v(r), p(r)]\), where \(r\) is of type Ref. To translate the initial permission expression to that form, we again define an inverse function, which maps a location reference to the value of the corresponding quantifier variable of Type T. The resulting quantified field chunk has the form \(r.f \mapsto [v(r), c(e^{-1}(r)) ? p(e^{-1}(r)) : 0)]\). %The domain of a quantified chunk is the set of fields r', where p(r' > 0). 

To guarantee the existence of an inverse function, it is necessary that the expression \(e(x)\) must be injective. This does not restrict the data structures that can be handled by this approach as long as correctly specified.

%Inhale
\paragraph{Quantified Inhaling:}
%Given a symbolic heap, a path condition and a quantified field permission, inhaling returns an updated heap and path conditions.
Inhaling a quantified field expression generates a new quantified heap chunk. In order to do that, we first evaluate the condition, receiver expression and permission expression. As a next step we introduce the inverse function of the expression \(e(x)\), which is only partially defined for the values where the given condition \(c(x)\) applies. The inverse function is defined by adding two conditions to the path conditions. As a last step, we generate the new quantified heap chunk using the previously defined inverse function  and add it to the heap. The value map is initially empty.

The symbolic execution rules are presented in table \ref{qfInhale}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{e}(y)) := eval(h_0, \pi_1 \cup \{\underline{c}(y)\}, e(y)) \)\\
\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_2, p(y)) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(Ref \rightarrow T\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall r: Ref \cdot \underline{c}(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Inhaling a Quantified Field Permission]
   {These symbolic execution rules for inhaling a quantified field permission correspond to the rules defined in figure 2 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}. The function \textbf{eval} is used to evaluate an expression in the given symbolic state. An evaluation may update the path variables, and yields the resulting symbolic expression. The symbolic value of the evaluated condition is added temporarily to the path condition for the evaluation of e(y) and p(y). These expressions may not be considered well-formed otherwise.}
\label{qfInhale}
\end{longtable}

%Exhale
\paragraph{Quantified Exhaling:}
Exhaling again starts by evaluating the condition, receiver expression and permission expression. As seen for verification condition generation, we check the injectivity of the receiver expression. Afterwards we introduce the inverse function same as before and proceed to remove the permission from the heap.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow acc(e(x).f, p(x))\) \{\\
\ident \textit{/* Evaluate Arguments (as above) */}\\
\ident [\dots] \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check} \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land \underline{e}(y_1) = \underline{e}(y_2) \Rightarrow  y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above) */}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var\ } h_1 := \) \textit{remove} \((h_0, \pi_6, f, (\lambda r \cdot \underline{c}(e^{-1}(r)) ? \underline{p}(e^{-1}(r)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Quantified Field Permission]
   {These symbolic execution rules for exhaling a quantified field permission correspond to the rules defined in figure 2 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}. The \textbf{check} instruction is translated to a query, which is sent to the SMT solver for verification. The function \textit{remove} is defined in table \ref{qfRemove}.}
\label{qfExhale}
\end{longtable}

Removing the permission will raise an error, if not enough permission is held. Otherwise the function will return the updated heap. Since we create a new quantified field chunk for every inhale, the permission required may be held in multiple chunks simultaneously. When removing a certain permission amount, we first filter all quantified chunks with the required field \(f\). 
We proceed to remove permissions greedily until we removed the required permission amount. Subtracting the permission for a specific chunk is expressed by defining introducing a function \(q_{current}\). After updating the permission for all quantified field chunks of field \(f\), we check that sufficient permission was taken and return the updated heap.
The symbolic execution rules for the function \textit{remove} are displayed in table \ref{qfRemove}.

%remove
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, q) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all chunks in given state for field \(f\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_f := \emptyset \) \\
\ident \textit{/* Permission still to take */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(r.f  \mapsto [v_i(r), q_i(r)] \in h_f\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda r \cdot min(q_i(r), q_{needed}(r))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda r\cdot q_{needed}(r) - q_{current}(r)) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_f := h'_f \cup \{r.f \mapsto [v_i(r), (q_i(r) - q_{current}(r))] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(r) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_f)  \cup h'_f \) \\
\}\\ \hline
\caption[Remove a Field Permission]
   {These symbolic execution rules for removing permission of a quantified field expression correspond to the rules defined in figure 3 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}. The argument \(f\) represents a field, \(q\) contains the permission amount needed per reference.}
\label{qfRemove}
\end{longtable}

\paragraph{Inhale Field Permission:}
In order to use the remove function defined, we need to adapt the approach for inhaling and exhaling unquantified field permissions. In Silicon, inhaling a single field permission is only adapted if the field occurs in a quantifier. In that case, inhaling a field permission produces a quantified field permission as well. To express the field permission \(acc(e.f, p)\)  as its equivalent quantified chunk, we define its permission as \(p\) if  the reference is equal to the location specified by the expression \(e\). The updated inhaling rules are presented in table \ref{sqfInhale}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  acc(e.f, p)\) \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1,\underline{e}) := eval(h_0, \pi_0, e)) \)\\
\ident \( \mathbf{var\ } (\pi_2,\underline{p}) := eval(h_0, \pi_1, p) \)\\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{r.f \mapsto [v(r), \}   (r == \underline{e})\ ?\ \underline{p} : 0]\) \\
\ident \textbf{return} \( (h_1, \pi_2) \) \\
\}\\ \hline
\caption[Inhaling a single Quantified Field Permission]
   {The symbolic execution rules for inhaling a field permission, where the field is quantified at some point during the program, is adapted in order to represent all permission to a quantified field as quantified chunks.}
\label{sqfInhale}
\end{longtable}

\paragraph{Exhale Field Permission:}
Exhaling a single field permission \(acc(e.f, p)\) is handled similarly. If a field is quantified, we reuse the function remove, defining the required permission as \(p\) if the location is equal to \(e.f\) and 0 otherwise. The updated exhaling rules are presented in table \ref{sqfExhale}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  acc(e.f, p)\) \{\\
\ident \textit{/* Evaluate Arguments (as above) */}\\
\ident [\dots] \\
\\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var\ } h_1 :=  remove(h_0, \pi_2, f, (\lambda r \cdot (r == \underline{e})\ ?\ \underline{p} : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Field Permission]
   {Analogous for inhaling a field permission, the symbolic execution rules for exhaling a field permission are adapted, if the field is quantified at some point during the program.}
\label{sqfExhale}
\end{longtable}

\paragraph{Evaluation}
The value information of a quantified field chunk is stored in its value map \(v\). It represents a under-specified total function and is defined per reference. A symbolic heap may consist of multiple chunks for the same field. To provide a simple translation for field-lookups, the function summarise was introduced. Given a field \(f\), it generates a value map, containing the values for all references defined, as well as the permission expressions held per location. Path conditions are not considered. The symbolic execution rules are defined in table \ref{qfSum}.

\begin{longtable}{| p{1\textwidth} | }
\hline
\textbf{summarise}\(\ (h_0, f) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for field \(f\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \(def := \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \(perm := \lambda r \cdot 0\) \\
\ident \textbf{foreach } \((r.f \mapsto [v_i(r), q_i(r)]) \in h_f \) \textbf{do:} \\
\ident \ident \(def := def \cup \{ \forall r \cdot 0 < q_i(r)  \Rightarrow v(r) = v_i(r) \} \) \\
\ident \ident \(perm := \lambda r \cdot (perm(r) + q_i(r)) \) \\
\ident \textbf{return } \((v, def, perm)\) \\
\}\\ \hline
\caption[Summarise Quantified Field Permissions]
   {These symbolic execution rules for summarising quantified field permissions correspond to figure 5 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}. It introduces a fresh value map and walks through all quantified field chunks of field \(f\), summarising the values for the defined locations and the permission for all references.}
\label{qfSum}
\end{longtable}

If we evaluate the value of a single field location \(e.f\), we first evaluate the location and summarise all heap chunks of field \(f\). After checking we hold sufficient permission, we read the value from the generated value function. The symbolic execution rules are presented in table \ref{qfEval}.

\begin{longtable}{| p{1\textwidth} | }
\hline
\textbf{eval}\(\ (h_0, \pi_0, e.f) \) \{\\
\ident \textbf{var } \((\pi_1, \underline{e}) :=\) \textbf{eval} \(h_0, \pi_0, e)\) \\
\ident \textbf{var } \((v, def, perm) :=\) \textbf{summarise} \(h_0, f)\) \\
\ident \textbf{check } \(\pi_1 \models 0 < perm(\underline{e}) \) \\
\ident \textbf{return } \(\pi_1 \cup def, v(\underline{e})\) \\
\}\\ 
\hline
\caption[Evaluate Field Permission]
   {These symbolic execution rules evaluating the value of a field permissions correspond to figure 6 of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}. It calls the function summarise and uses the looks up the value of the given location in the returned value map.}
\label{qfEval}
\end{longtable}

\paragraph{Field Write}
A field write \(e_1.f := e_2\) is desugared into exhaling and then inhaling the access permission of the field \(e_1.f\), followed by inhaling the equality of \(e_1.f\) and \(e_2\). Exhaling the permission of the field checks whether we possess sufficient permission to write to the field. The rules are presented in table \ref{qfWrite}

\begin{longtable}{| p{1\textwidth} | }
\hline
\textbf{execute}\(\ (h_0, \pi_0,e_1.f := e_2) \) \{\\
\ident \textbf{exhale } \(acc(e_1.f)\) \\
\ident \textbf{inhale } \(acc(e_1.f)\) \\
\ident \textbf{inhale } \( e_1.f == e_2\) \\
\}\\ 
\hline
\caption[Evaluate Field Permission]
   {These symbolic execution rules for desugaring a field write for a quantified field.}
\label{qfWrite}
\end{longtable}

%triggering
%framing


\section{Generalising Quantified Field Permissions in Carbon}
\label{genField}
The approach presented in section \ref{cgqf} did not include any trigger. To restrict the 
Some expressions generated in Carbon did not include any triggers. To reduce unnecessary invocations, we introduced new triggers for these expressions.

Additionally we intended to support user-given triggers. Most generated expressions should trigger independently of that trigger. For example, it is unnecessary to add the trigger to the expressions defining the new Mask. Since they describe the Mask properties are expressed from a neutral field read, they are triggered for all relevant expressions regardlessly. The injectivity assertion on the other hand, should never be triggered. For that purpose, we introduce a new function to set as a trigger, which is later on never used.

The last two changes are a general change to the approach as shown before. As a Carbon-specific change , we decided to reuse the trigger generation, which Carbon uses for pure quantifiers. As a current restriction, we impede the generation of additional variables for triggers due to the fact that nested quantifiers are not yet supported in carbon.


%carbon inhale quantified field. Frame?
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x).f, p(x)) \) \{\\
\ident Let \textit{qpMask} be a new Mask   \\
\ident \textbf{havoc} qpMask \\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{e(x)\} \{trs\}\ \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:Ref ::\{inv(r)\}\ c(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* all receiver is non-null */} \\
\ident \textbf{assume } \( \forall x:T ::\{e(x)\} \{trs\}\ \underline{c}(x)  \Rightarrow \underline{e}(x)) != null \) \\
\\
\ident \textit{/* assume e(x) is injective */} \\
\ident \textbf{assume\ }\(\forall y_1: T, y_2:T ::\{e(y_1), e(y_2), trs(y_1), trs(y_2)\}\ y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{qpMask(r, f)\}\ \{ inv(r)\}\ c(inv(r)) \Rightarrow qpMask(r, f) = Maks(r.f) - Mask(inv(r), f)\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{ qpMask(r, f)\}\ \{ inv(r)\}\ \neg c(inv(r)) \Rightarrow qpMask(r, f) = \) Mask \((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:Object, f_o:Field :: \{Mask(o, f) \}\ \{ qpMask(o, f)\}\ (f_o != f) \Rightarrow qpMask(o , f) = \) Mask \((o,f) \)\\
\ident \textbf{return} qpMask \\
\}\\ \hline
\caption[carbon quantified field inhale]
   {The expressions generated during a quantified inhale are adapted for the first inverse function assumption, as well as the non-null assumption. Both expressions are triggering on the expression denoting the receiver, and the user-given or automatically generated trigger.} %expand description: check, remove....
\label{qfconditionInhaleExtended}
\end{longtable}

%carbon exhale quantified field
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{exhale forall } \(x:T :: c(x) \Rightarrow  acc(e(x), p(x)) \) \{\\
\ident Let \textit{qpMask} be a new Mask   \\
\ident \textbf{havoc} qpMask \\
\ident \textit{/* assert e(x) is injective */} \\
\ident \textbf{assert\ }\(\forall y_1: T, y_2:T ::\{triggerFun(e(y_1)), triggerFun(e(y_2))\}\  y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow \underline{e}(y_1) = \underline{e}(y_2)\) \\
\\
\ident \textit{/* sufficient permission */} \\
\ident \textbf{assert\ } \(\forall x:T ::\{\}\ c(x) \Rightarrow Mask(e(x), f) \geq p(x)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow \) \textit{Ref} \\
\ident \textbf{assume } \( \forall x:T ::\{e(x)\} \{trs\}\  \underline{c}(x)  \Rightarrow e^{-1}(\underline{e}(x)) = x \) \\
\ident \textbf{assume\ } \( \forall r:Ref ::\{inv(r)\}\  c(e^{-1}(r))  \Rightarrow \underline{e}(e^{-1}(r)) = r \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{qpMask(r, f)\}\ \{ inv(r)\}\ c(inv(r)) \Rightarrow qpMask(r, f) = Maks(r.f) - Mask(inv(r), f)\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall r:Ref :: \{Mask(r, f)\}\ \{ qpMask(r, f)\}\ \{ inv(r)\}\ \neg c(inv(r)) \Rightarrow qpMask(r, f) = \) Mask \((r, f) \)\\
\ident \textbf{assume\ } \(\forall o:Object, f_o:Field :: \{Mask(o, f) \}\ \{ qpMask(o, f)\}\ (f_o != f) \Rightarrow qpMask(o , f) = \) Mask \((o,f) \)\\
\ident \textbf{return} qpMask \\
\}\\ \hline
\caption[carbon quantified field exhale]
   {Translating quantified field exhale operation. trs signifies a user-defined trigger or if no trigger was given, a set of auto-generated triggers as used for pure quantifiers}
\label{qfconditionExhaleExtended}
\end{longtable}

\section{Quantified Predicate Permissions}
\label{qp}
In order to generalise the form of quantified permissions, we lift the restriction on the type of the location. In this section we discuss how the presented solution for quantified field permission has to be adapted in order to support quantified predicate permissions. 
As the general form of a quantified predicate permission we consider the following adaption of the form presented for quantified field permissions: 
\begin{equation}
 \mathbf{forall} \   x:T :: c(x) \Rightarrow acc(pred(e_1 (x),…,e_n (x)), p(x)), 
\end{equation}
where \(c(x)\) is a Boolean expression, \textit{pred} a predicate name, \(\ e_i(x)\) denotes the expression conforming to the type of the ith arguments of the predicate \textit{pred} and \(p(x)\) permission expression.

Introducing this new form allows us to express permission to more complex structures such as a set of lists.

To explain the adaption needed for the implementation, we again discuss the answers to the following questions:
\begin{enumerate}
\item How to model the program state, including permissions and values?
\item How to check for a permission in a state?
\item How to add and remove permissions to and from a state?
\item How to evaluate (heap-dependent) expressions in a state?
\item When to preserve (frame) an expression's value across heap changes?
\end{enumerate}
%Example

For Verification Condition Generation, these questions are answered in the following section \ref{vcgPredicate}. For Symbolic Execution, the first problem is handled in section \ref{shr}, the second and third in section \ref{qpInhaleSec} to \ref{pInhaleExhaleSec}. The fourth and fifth question is answered  in section \ref{qppVals} to section \ref{qpUnfolding}.

\subsection{Verification Condition Generation for Quantified Predicate Permissions}
\label{vcgPredicate}
In Carbon, the permission held for a predicate instance is stored in the map \textit{Mask}. The permissions held to a predicate location of the predicate \textit{pred} with n arguments is stored at \textit{Mask}\([null, pred(arg_1, \dots, arg_n)]\). Similar to the approach for quantified predicate permissions, we introduce a translation for inhaling and exhaling quantified predicate permissions. There are no adaptions needed for the definition of the program state, nor do we need to change anything concerning the evaluation of  permissions. The implementation of the operations unfold, fold and unfolding does not have to be changed. 

Framing is done as for quantified field permissions by defining a new map, which later replaces the current map. For this map, we define all known permissions. For the locations included within a quantifier, the permission is increased or decreased by the designated amount. For the independent locations the permission remains unchanged. These include all field and magic wand locations, predicate instances of different predicate names, as well as predicate instances not satisfying the quantifier condition.

To translate a quantified predicate permission, we reuse the solution presented for quantified fields. As for quantified field permissions, we evaluate the arguments, introduce an inverse function, assume injectivity and define the updated permissions for the newly created map holding the permissions for predicates. We need, however to redefine the definition of the inverse function and injectivity.

A predicate location is defined by a predicate name and a set of arguments. As before we wish to define the updated locations using a quantified neutral location. Whereas the approach for quantified field permission uses a fix reference \(r\) to find the general location of a field, a neutral predicate depends on a set of arguments. The number of arguments and their type may differ for each predicate. To express the neutral locations, we declare a set of neutral arguments \(arg_1, \dots, arg_n\) for each quantified predicate definition. 

In order to translate the given permission for that location, we need to adapt the definition of the inverse function presented in section \ref{qf}. As before, the inverse function is used to map a general location to the variable used in the original quantified permission expression. A new inverse function is defined for each expression. Since the predicate name is however independent of the quantifier variable, it is not necessary to include it as an argument of the inverse function. The adapted definition of the inverse function is only depending on the arguments themselves.

As before, given the arguments of the predicate, the new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier. The adapted inverse function is defined as:\\

\begin{tabularx}{1\textwidth}{ X}
\textbf{function }\(e^{-1}(a_1:A_1, \dots, a_n:A_n): T\) \\
\(\forall \ x:T :: c(x) \Rightarrow e^{-1}(e_1 (x),…,e_n (x))==x \) \\
\( \forall \ a_1:A_1,\dots, a_n:A_n ::  c(e^{-1}(a_1, …,a_n )) \Rightarrow e_i (e^{-1}(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}\\

The inverse function is, as before, a partial function defined only for values where the condition of the original quantifier applies.

Similar to quantified field permissions, we have to restrict the allowed expression terms as a result to guarantee the existence of the defined inverse function. The location expressed by the quantifier has to be injective.This is guaranteed if at least one argument expression differs for all two values of the quantifier variable. This property can be expressed by the following equation:\\

\begin{tabularx}{1\textwidth}{ X}
 \(\forall x_1:T, x_2: T :: c(x_1) \land c(x_2) \land (e_1(x_1) = e_1(x_2)) \land \dots \land  (e_n(x_1) = e_n(x_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(x_1 = x_2\) \\
\end{tabularx}\\

The adapted translations of inhaling and exhaling quantified predicate permissions are depicted in table \ref{qpcInhale} and table \ref{qpcExhale}.

%carbon missing: triggers
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),\dots,e_n (x)), p(x)) \) \{\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \(\underline{e_1} := eval(e_1)\)\\
\ident \([\dots]\) \\
\ident \(\underline{e_n} := eval(e_n)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \textbf{assume } \( \forall x:T :: \{\} \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\ident \textbf{assume\ } \( \forall a_1: A_1, \dots, a_n: A_n :: \{e^{-1}(a_1, \dots, a_n)\} \ c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\\
\ident \textit{/* Injectivity Assumption */} \\
\ident \textbf{assume\ }\(\forall y_1:T, y_2:T\ \{\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \lor  (\underline{e_n}(y_1) \ne \underline{e_n}(y_2))\) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{qpMask[null, pred(a_1, \dots, a_n)\}\) \\
\(\{Mask[null, pred(a_1, \dots, a_n)\}\{e^{-1}(a_1, \dots, a_n)\} \ c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)]  +  p(inv(a_1, \dots, a_n))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\}\ \neg c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)] \)\\
\ident \textbf{assume\ } \(\forall o:Ref, f:Field :: \{qpMask[o, f]\} \{Mask[o, f]\}\ (obj \ne null \land \neg isPredicateField(f) \land predicateId(f) != predicateId(pred)) \Rightarrow perm(o.f , a_n)) = \) \textbf{old} \((perm(o.f)) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon quantified predicate inhale]
   {Translation of inhaling a quantified predicate permission. The corresponding translation for quantified field permissions is displayed in table \ref{qfconditionInhale}. The translation differs in the definition of the general location, the inverse function and the injectivity assumption. Additionally, there is no need for a non-null assumptions for predicates. The independent locations include all instances not satisfying the condition \(c(x)\), as well as  all mask entries not pointing to a predicate instance of \(pred\). To distinguish predicates by the predicate name, we introduce the function \textit{predicateId}, which is unique for each predicate name and generated when translating a predicate declaration.}
\label{qpcInhale}
\end{longtable}

%carbon exhale quantified field
\begin{longtable}{| p{1\textwidth} |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),\dots,e_n (x)), p(x)) \) \{\\
\ident \textbf{havoc} qpMask \\
\ident \underline{c} \(:= eval(c)\)\\
\ident \(\underline{e_1} := eval(e_1)\)\\
\ident \([\dots]\) \\
\ident \(\underline{e_n} := eval(e_n)\)\\
\ident \underline{p} \(:= eval(p)\)\\
\\
\ident \textit{/* Injectivity Assumption */} \\
\ident \textbf{assume\ }\(\forall y_1:T, y_2:T\ \{\} : y_1  \ne y_2 \land \underline{c}(y_1) \land \underline{c}(y_2) \Rightarrow ((\underline{e_1}(y_1) \ne \underline{e_1}(y_2)) \lor \dots \lor  (\underline{e_n}(y_1) \ne \underline{e_n}(y_2))\) \\
\\
\ident \textit{/* sufficient permission assertion*/} \\
\ident \textbf{assume\ } \(\forall x:T :: \{\} c(x) \Rightarrow Mask[null, pred(\underline{e_1}(x), \dots, \underline{e_n}(x))]  \geq \underline{p}(x)\)\\
\\
\ident \textit{/* Inverse Assumptions */} \\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \textbf{assume } \( \forall x:T :: \{\} \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\ident \textbf{assume\ } \( \forall a_1: A_1, \dots, a_n: A_n :: \{e^{-1}(a_1, \dots, a_n)\} \ c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\\
\ident \textit{/* define updated permission */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{qpMask[null, pred(a_1, \dots, a_n)\}\) \\
\(\{Mask[null, pred(a_1, \dots, a_n)\}\{e^{-1}(a_1, \dots, a_n)\} \ c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)]  -  p(inv(a_1, \dots, a_n))\)\\
\\
\ident \textit{/* define independent permissions */} \\
\ident \textbf{assume\ } \(\forall a_1:A_1, \dots,  a_n:A_N :: \{tr\}\ \neg c(inv(a_1, \dots, a_n)) \Rightarrow qpMask[null, pred(a_1, \dots, a_n)] == Mask[null, pred(a_1, \dots, a_n)] \)\\
\ident \textbf{assume\ } \(\forall o:Ref, f:Field :: \{qpMask[o, f]\} \{Mask[o, f]\}\ (obj \ne null \land \neg isPredicateField(f) \land predicateId(f) != predicateId(pred)) \Rightarrow perm(o.f , a_n)) = \) \textbf{old} \((perm(o.f)) \)\\
\ident Mask \(:=\) qpMask \\
\}\\ \hline
\caption[carbon quantified predicate exhale]
   {Translation of exhaling a quantified predicate permission.The corresponding translation for quantified field permissions is displayed in table \ref{qfconditionExhale}. The translation differs in the definition of the injectivity check, the general location and the inverse function.}
\label{qpcExhale}
\end{longtable}

%TODO: triggering

\subsection{Symbolic Execution}
In this section, we adapt the solution for quantified field permissions described in section \ref{seqfp} to support quantified predicate permissions for symbolic execution.

\subsubsection{Symbolic Heap Representation} \label{shr}
In order to reason about quantified predicate permissions, it is necessary to define a symbolic heap representation for a potentially unbound set of predicate instance of the same predicate simultaneously. In the previous design, a quantified field chunk is defined by the field name, where permission and value are defined using a general location reference \(r\).
For quantified predicate chunks we use the predicate name instead of the field as identification and express the permission and value definition by defining a set of general arguments. The general form of such a heap chunk conforms to:
\begin{equation}
	\mathbf{pred}(\mathrm{arg_1, ..., arg_n})\mapsto [v(\mathrm{arg_1, ..., arg_n}), p(\mathrm{arg_1, ..., arg_n}))],
\end{equation}
where \textit{v} represents a value map, where a value represent the snapshot of that predicate instantiation.
Given the new definition of quantified predicate heap chunks, we define the \(inhale\) and \(exhale\) operations for quantified predicate permissions.

\subsubsection{Quantified Inhaling} 
\label{qpInhaleSec}
The adapted symbolic execution rules for a inhaling a quantified permission can be seen in figure \ref{qpInhale}. It differs in the definition of the inverse function, as well as the values of the value map.

As before, inhaling a quantified predicate permission updates a given state and returns an updated heap and path condition. Similarly the quantified field expression, the condition, argument expressions and permission expression are evaluated as a first step.

The inverse function is introduced analogous to a quantified field permission and further defined by adding two constraints to the path condition, defining its properties. The the cardinality of the inverse function may vary for different predicates, but is identical for the same predicate.

As a last step we introduce a value map, which is later used to keep track of the snapshot of predicate instantiations. These values are used during an unfold or unfolding.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \)  \textbf{forall } \(x:T :: c(x) \Rightarrow \)  \textbf{acc} (\textit{pred}  \( (e_1 (x),…,e_n (x)), p(x)) \)  \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}(y)) := eval(h_0, \pi_{2_{n-1}}, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(A_1, \dots, A_n \rightarrow T\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident \textit{/* Introduce value map */}\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Inhaling a Quantified Predicate Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission. They refer to the rules for inhaling quantified field permissions of figure \ref{qfInhale}. The declaration of the inverse function is updated as described before. The inverse function takes a set of predicate arguments and returns the value of the variable originally expressed in the quantifier. The type of the value map corresponds to the snapshot type of the predicate.}
\label{qpInhale}
\end{longtable}

\subsubsection{Quantified Exhaling} 
\label{qpExhaleSec}
The adaptations necessary for exhaling quantified predicate permissions again include an update for evaluating the argument expressions, as well as the introduction of the inverse function as defined for inhaling. Additionally, the injectivity check needs to be adapted as defined in the previous section. The new rules are defined in table \ref{qpExhale}.

After evaluating the expressions denoted by the quantified predicate permission, we check the injectivity before introducing the inverse functions as defined in the inhaling. The check passes if for any two variables satisfying the initial condition,  at least one argument expression is evaluated to a different symbolic value.

The definition of removing permission from a quantified predicate is adapted as well. It filters quantified chunks to include only the chunks with the given predicate name. We again iterate through these chunks, taking permission greedily and check whether enough permission was taken as a final step. The definition of \(q_{needed}\) and \(q_{current}\) is adapted to take a set of predicate arguments. The updated definition for the function remove can be seen in table \ref{qpRemove}.

%exhale
\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\caption[Exhaling a Quantified Predicate Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission. The corresponding rules for quantified field permission is displayed in table \ref{qfExhale}. The changes include the updated definition of the injectivity check, inverse function and general predicate location.} %expand description: check, remove....
\label{qpExhale}
\end{longtable}

%remove
\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{remove}\(\ (h_0, \pi_0, pred, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\caption[Remove a Quantified Predicate Permission]
   {Symbolic execution rules for removing a quantified predicate permission. The corresponding rules for quantified field permission is displayed in table \ref{qfRemove}. The changes include the updated filtering of chunks by the predicate name, as well the cardinality of the input parameter of \(q_{current}\) and \(q_{needed}\), which are used to define the amount of permission subtracted per chunk.}
\label{qpRemove}
\end{longtable}

\subsubsection{Inhaling and Exhaling Single Predicate Permission} 
\label{pInhaleExhaleSec}
In order to use the remove function defined, we again need to adapt the approach for inhaling and exhaling single predicate permissions. When inhaling, we define a quantified predicate chunk, where the permission is defined only if all arguments are identically to the input arguments. When exhaling a predicate permission, we define the needed permission the same way. Analogous for the implementation of quantified fields, silicon only adapts the inhaling and exhaling of single predicates, if the predicate is quantified at some point in the given program.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  acc(pred(a_1, \dots, a_n), p)\) \{\\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_{1},\underline{e_1}(y)) := eval(h_0, \pi_0 \cup \{ \) \underline{c}\( (y)\}, e_{1})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{n},\underline{e_n}(y)) := eval(h_0, \pi_{n-1}, e_{n})) \)\\
\ident \( \mathbf{var\ } (\pi_{n+1},\underline{p}) := eval(h_0, \pi_n, p) \)\\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), ((a_1 == \underline{e}_1) \ \&\&\ \dots \ \&\&\ (a_n == \underline{e}_n)) ? \ \underline{p} : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_{n+1}) \) \\
\}\\ \hline
\caption[Inhaling a single Quantified Field Permission]
   {The symbolic execution rules for inhaling a predicate permission, where the predicate is quantified at some point during the program, is adapted in order to represent all permission to the quantified predicate in quantified chunks. These rules correspond to the rules displayed for quantified field permission in table \ref{sqfInhale}. The definition of the quantified predicate chunk generated is adapted to consider all arguments of the predicate.}
\label{sqpInhale}
\end{longtable}

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{exhale}\(\ (h_0, \pi_0,  acc(e.f, p)\) \{\\
\ident \textit{/* Evaluate Arguments (as above) */}\\
\ident [\dots] \\
\\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var\ } h_1 :=  remove(h_0, \pi_{n+1}, f, (\lambda a_1, \dots, a_n \cdot ((a_1 == \underline{e}_1) \ \&\&\ \dots \ \&\&\ (a_n == \underline{e}_n))\ ?\ \underline{p} : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_{n+1}) \) \\
\}\\ \hline
\caption[Exhaling a Field Permission]
   {Analogous for inhaling a predicate permission, the symbolic execution rules for exhaling a predicate permission are adapted, if the predicate is quantified at some point during the program. These rules correspond to the rules displayed for quantified field permission in table \ref{sqfExhale}. The definition of the permission required is adapted to consider all arguments of the predicate.}
\label{sqpExhale}
\end{longtable}

\subsubsection{Treatment of Symbolic Values} 
\label{qppVals}
Predicates may modify symbolic values while unfolding and folding predicates. When working with quantified predicates, the unfold and fold operations need to be adapted. Unfolding a predicate can be desugared as before. As for exhaling and inhaling single predicates, the functions fold and unfold only need to be adapted for predicates which are quantified at some point during the program.

In order to summarise the values and permission of a single predicate, we adapt the summarise function presented for quantified field permission. The function walks through all quantified chunks of the given predicate, keeping track of the values and permissions held for all locations. The symbolic execution rules are displayed in table \ref{qpSum}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{summarise}\(\ (h_0, pred) \) \{\\
\ident Let \(h_f \subseteq h_0\) be all quantified chunks in the given heap for predicate \(pred\) \\
\ident Let \(v\) be a fresh value map\\
\ident \textit{/* Value summary path conditions */} \\
\ident \textbf{var } \(def := \emptyset \) \\
\ident \textit{/* Permission summary */} \\
\ident \textbf{var } \(perm := \lambda r \cdot 0\) \\
\ident \textbf{foreach } \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:}\\
\ident \ident \(def := def \cup \{ \forall a_1, \dots, a_n \cdot 0 < q_i(a_1, \dots, a_n)  \Rightarrow v(a_1, \dots, a_n) = v_i(a_1, \dots, a_n) \} \) \\
\ident \ident \(perm := \lambda a_1, \dots, a_n \cdots (perm(a_1, \dots, a_n) + q_i(a_1, \dots, a_n)) \) \\
\ident \textbf{return} \((v, def, perm)\) \\
\}\\ \hline
\caption[Summarise Quantified Field Permissions]
   {Symbolic execution rules for summarsing quantified predicate permissions. The function is adapted from the summarise function for quantified field permission depicted in table \ref{qfSum}}
\label{qpSum}
\end{longtable}

\subsubsection{Unfold} 
\label{qUnfold}
When unfolding a quantified predicate, we first evaluate the arguments of the predicate and summarise the quantified predicate chunks in order to evaluate the predicate's snapshot. As a next step, we relinquish the permission for the predicate instance by exhaling write permission to the predicate instance, followed by inhaling the snapshot, which is a representation of the body of the predicate. The symbolic execution rules for the unfold operation are displayed in table \ref{qUnfold}.

\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{unfold}\(\ (h_0, \pi_0, pred(e_1, \dots, e_n))\) \{\\
\ident \textit{/* evaluate arguments */} \\
\ident \( \mathbf{var\ } (\pi_{1},\underline{e_1}) := eval(h_0, \pi_0, e_1)) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{n},\underline{e_n}) := eval(h_0, \pi_0, e_n)) \)\\
\\
\ident \textit{/* read the predicate's snap value */} \\
\ident \textbf{var } \((v, \) \textit{def}, \textit{perm}\() :=\) \textit{summarise} \((h_0, pred)\) \\
\ident \textbf{var } snapshot \(:=\) \( v (\underline{e_1}, \dots, \underline{e_n})\)\\
\\
\ident \textbf{var } \((h_1, \pi_{n+1}) :=\) exhale\((h_0, \pi_n \cup def, pred(e_1, \dots, e_n))\) \\
\ident \textbf{var } \((h_2, \pi_{n+2}) :=\) inhale\((h_1, \pi_{n+1}, snapshot)\) \\
\ident \textbf{return} \( (h_2, \pi_{n+2}) \)  \\
\}\\ \hline
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for the unfold operation. The function summarise refers to the function declared in table \ref{qpSum}. Inhaling the snapshot of the predicate is equal to inhaling the predicate body for the values denoted by the snapshot.}
\label{qUnfold}
\end{longtable}

%overview
\subsubsection{Fold} 
\label{qFold}
As mentioned in the background, folding a predicate exchanges the permission of the body with the permission to the predicate which is being folded. It creates a new quantified predicate chunk. The predicate chunk contains the values of the permissions held by the predicate body previous to folding it, which is called a snapshot of the predicate.

When folding a quantified predicate, we first generate a snapshot based on the current heap. Exhaling the snapshot is equivalent to exhaling the body of the predicate, where the values the body relies on are revealed in the snapshot. Exhaling the snapshot is checking that enough permission is held to fold the predicate. After exhaling the predicate body, we generate a new quantified predicate chunk, where the value map is defined for the given predicate and maps to the generated snapshot.

The symbolic execution rules for the operation fold can be seen in figure \ref{qFold}.
%fold
\begin{longtable}{| p{1\textwidth} | } 
\hline
\textbf{fold}\(\ (h_0, \pi_0, pred(e_1, \dots, e_n))\) \{\\
\ident \textit{/* evaluate arguments */} \\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}) := eval(h_0, \pi_0, e_1)) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_n}) := eval(h_0, \pi_0, e_n)) \)\\
\\
\ident \textit{/* generating the predicate's snap value */} \\
\ident \textbf{var } snapshot \(:=\) \textit{generateSnap}\((h_0, pred, (\underline{e_1}, \dots, \underline{e_n}))\)\\
\\
\ident \textbf{var } \((h_1, \pi_{n+1}) :=\) exhale\((h_0, \pi_n, snapshot) \) \\
\ident Let  \(v\)  be a fresh value map \\
\ident \(v(\underline{e}_1, \dots, \underline{e}_n) = snapshot\)\\
\ident \( \mathbf{var\ } h_2 :=  h_1 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), ((a_1 == \underline{e}_1) \ \&\&\ \dots \ \&\&\ (a_n == \underline{e}_n)) ? \ 1 : 0] \}  \) \\
\ident \textbf{return} \( (h_2, \pi_{n+2}) \)  \\
\}\\ \hline
\caption[Unfold  a Quantified Predicate Permission]
   {Symbolic execution rules for folding a quantified predicate. This adaption is only needed for predicates, which are quantified at some point in the given program. It exhales the predicate body and generates a new quantified chunk which holds the snapshot generated before exhaling the body.}
\label{qFold}
\end{longtable}

%silicon

\subsection{Implementation}
We implemented both approaches presented. The approach for verification condition generation is implemented in Carbon and does not differ from the approach.

The approach for symbolic execution is implemented in Silicon. There are a few subtle differences between the approach and the implementation. As for quantified field permission, Silicon analyses the program given, creating a list of quantified predicates. Additionally, it also precomputes a set of predicate arguments used to express the general predicate locations in quantified heap chunks and assertions generated, as well as a general snapshot. The predicate arguments added to the state.
Exhaling a single predicate instance provides the snapshot of that predicate. Removing a certain permission amount is implemented - as for quantified field permissions - as a combination of the presented functions remove and summarise. This is straightforward, since both iterate through the quantified predicate chunks filtered by the predicate name.

\subsubsection{Issues}
Triggering Sequences

Quantified unfolding

%Quantified Magic Wands
\section{Quantified Magic Wands}
As mentioned in chapter , a magic wand is represented using its footprint. A footprint may consist of multiple arguments. As a consequence, the definition for the inverse function and the injectivity test is defined analgous to quantified predicate permissions.

In verification condition generation, a magic wand instance is represented in the form wand\( (f_1, \dots, f_n) \), where \(f_i\) represents the ith argument of the magic wand's footprint. The definitions for inhaling and exhaling a quantified magic wand is done exaclty as in figure \ref{qpcInhale} and \ref{qpcExhale}, where the predicate name is replaced with wand, and the argument expressions correspond to the footprints.
Again, there is no need to adapt the implementations of \textit{apply} and \textit{package}.

As for symblolic execution rules, the same principle applies.%Go on?

%Combinations of Quantifiers
\section{Combinations of Quantifiers}
Viper currently does not allow to merge pure and permission-based quantifiers, nor does it allow combinations of multiple quantified permissions. This can be circumvented by repeating the definitions prior to the quantified expression.
To decrease the code size for specifying the properties desired and support user-friendliness it would however be desirable to lift this restriction.

We consider adding the support of the following expressions:
\begin{equation}
\label{eq1}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))
\end{equation}
\begin{equation}
\label{eq2}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x)),
\end{equation}
where {\it trs} is a set of triggers and {\it c(x)} a Boolean expression. The expression {\it e(x)} can be either pure or permission-based. In the second case it should be either of the expressions which were already supported before - a field permission, predicate permission or magic wand permission - or combination of these expressions. For the first newly introduced quantified expression, the sub-expressions \(e_1(x))\) and \(e_2(x)\) have to be injective, as should be \( e(x)\) in the second equation.

The first expression allows to combine two expressions on the right-hand side of the implication. The second expression  grants us the ability to refine a condition. Both are currently only allowed if they are entirely pure. An example using this new feature would be: 

\begin{lstlisting}
field f: Int
field g: Int

method m1(r:Ref, xs: Seq[Ref], b:Int)
requires forall x:Ref :: x in xs ==> (b ==> acc(x.f)) && (!b ==> acc(x.g))
ensures forall x:Ref :: x in xs ==> (b ==> acc(x.f)) && (!b ==> acc(x.g))
ensures b? (x.f == 2) : (x.g == 3)
{
    if (b)
    {
        x.f := 2
    }
    else
    {
        x.g := 3
    }
}
\end{lstlisting}

Other combinations using Boolean expressions are currently not considered unless they are part of a Boolean expression. This is due to the fact, that Viper does not supported them permission-based expressions as well.

\subsection{Conjunction}
As a first solution we propose to adapt the symbolic execution rules to handle these cases.
If the entire expression is fully pure, this is handled as previously.The sub-expressions of the combinations may be depending on each other. An example for this would be: 
\begin{equation}
\label{eq1}
	\mathbf{forall} \; x:T :: \{\}\  x\ \mathrm{in \ Set} \{\dots\} \Rightarrow acc(x.f) \ \&\& \ (x.f > 0)
\end{equation}
As a consequence, both expressions have to be evaluated sequentially. 
Let's consider the case where both subexpressions denote a field permission. Due to the sequentiality constraint, we treat the first expression as before. We cannot generally reuse the inverse function and injectivity definition for the second expression as defined before. A adaption to the rules would therefore skip the evaluation of the condition, but essentially repeat all other steps for the second expression.
If one of the expressions is pure, we treat it independently as before.

As a second solution, we therefore propose to rewrite the given quantifiers to two quantifiers, so that the rewritten quantifiers allow us to reuse the symbolic execution rules presented: 
\begin{equation}
\begin{aligned}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))  \mapsto \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x)  \Rightarrow e_1(x)) \ \&\& \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x) \Rightarrow  e_1(x))
\end{aligned}
\end{equation}

As mentioned before, there is only a minimal advantage in adapting the symbolic rules due to the fact that the condition is evaluated multiple times. The value could also be cached. The triggers are passed along to both quantifiers.

\subsection{Refining}
Similar to the solution presented for the conjunction of expressions within a quantifier, besides having the option of adapting the symbolic execution rules for the previously shown solutions, we can desugare the expression to the already supported form by using its logical equal:
\begin{equation}
\begin{aligned}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x))  \mapsto \\
	\mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x))
\end{aligned}
\end{equation}

\subsection{Example}
The forall expression of the example is rewritten to the following way: \\

\begin{tabularx}{1\textwidth}{ X }
\(\mathbf{forall\ } x:Ref :: x\ in\ xs \Rightarrow (b \Rightarrow  acc(x.f)) \:\&\&\ (!b \Rightarrow acc(x.g)) \mapsto \) \\
\((\mathbf{forall\ } x:Ref :: x\ in\ xs \Rightarrow (b \Rightarrow  acc(x.f))) \:\&\&\ (\mathbf{forall\ } x:Ref :: x\ in\ xs \Rightarrow (!b \Rightarrow acc(x.g)) \mapsto \) \\
\((\mathbf{forall\ } x:Ref :: (x\ in\ xs)  \:\&\&\ b \Rightarrow acc(x.f)) \:\&\&\ (\mathbf{forall\ } x:Ref :: (x\ in\ xs)  \:\&\&\ !b \Rightarrow  acc(x.g)) \) \\
\end{tabularx}


\subsection{Implementation}
The implementation for supporting the combinations presented uses the rewriting rules mentioned above. The desugaring takes place during the parsing of the program. Both Carbon and Silicon accept the same program with the already rewritten expressions.

%Nested Quantifiers
\section{Nested Quantifiers}
%Why nested quantifiers?
In this section we present another adaption removing the restriction that a quantified permission may depend on one variable only. After applying the rewriting rules given in section \ref{rewriting}, there are two forms of nested quantifiers which are desirable to support.

In the first structure, all variables are defined at once, allowing condition and expression to depend on all of them:\\

\begin{tabularx}{1\textwidth}{ X }
	\( \mathbf{forall} \; x_1:T_1, \dots, x_n: T_n ::  \{trs\}\ c(x_1, \dots, x_n) \Rightarrow \) \\
	\(e(x_1,  \dots, x_n)\)
\end{tabularx}\\

The expression \(e(x_1,  \dots, x_n)\) stands for any unquantified permission where we presented a quantified solution in the previous chapters, Pure quantifiers of this form are already supported in Viper. For the support of this new quantified expression we present a new generalisation of the previously shown algorithms in section \ref{generalN}.\\

The second structure represents a truly nested quantifier, where on the right-hand side of the implication. The following formula represents such a form with two quantifiers:\\

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\end{tabularx}\\

Here the expression \(e(x_1, x_2)\) can, as mentioned before, be any permission expression introduced or another quantified expression. As a solution we present a new rewriting rule in section \ref{rewritesN}.

Both formulas allow us to define more complex quantifiers, for example access rights to a matrix, without resorting to reformulate them 

\subsection{Generalisation for Nested Quantified Permissions}
\label{generalN}




\subsubsection{Symbolic Heap Representation}
By changing the number of variables a quantifier depends on, we do not need to change the design of the heap chunks itself. Both the types and arguments do not change. The way to translate an argument to its neutral form, however, does. We need a way to retrieve the original variables using inverse functions. In order to do that, we introduce \(n\) inverse functions, which each map from a general location to the value of one variable.

In order to translate the given permission to that form, we need to adapt the definition of inverse function. The new inverse function returns a value of type \(T\) corresponding to the original value of the quantifier given the arguments of the predicate. The adapted inverse functions for quantified field and predicate permissions can be seen in figure \ref{nInv}.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{ X}
\textit{/* Nested Field Quantifie */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),…,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_n(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_n(a_1,\dots, a_n )) = a_i \) \\
\\
\textit{/* Nested Predicate Quantifier */}\\
\textbf{function }\(inv_i(a_1:A_1, \dots, a_n:A_n): T_i\) \\
\( \mathbf{forall \ }  x_1:T_1, \dots, x_n:T_n :: c(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident \(inv_i(e_1 (x_1, \dots, x_n),…,e_n (x_1, \dots, x_n))==x_i \) \\
\( \mathbf{forall \ }  a_1:A_1,\dots, a_n:A_n ::  c(inv_1(a_1, \dots ,a_n ), \dots, inv_n(a_1, \dots, a_n)) \Rightarrow \) \\
\ident \ident \ident \(e_i (inv_1(a_1,\dots, a_n ), \dots, inv_n(a_1,\dots, a_n )) = a_i \) \\
\end{tabularx}
\caption[Nested Inverse Functions]
   {Inverse Function definitions for nested quantifiers for quantified field and predicate permissions, for all inverse functions \( i\), where \( 1 \leq  i \leq  n \).}
\label{nInv}
\end{figure}

Using these inverse functions also enforces us to restrict the allowed expressions for nested quantifiers. \(e(x)\) has to be injective. These new conditions are shown in figure.


\subsubsection{Treatement of Permissions}
With the new quantified predicate heap chunks defined above, we redefine \(inhale\) and \(exhale\) operations for quantified predicate permissions.

Inhaling a nested quantified permission is now done using the inverse definition shown before. The newly generated heap chunk uses the inverse functions to whether the conditions of the general locations are met, as well as the determination of the permission amount itself.

\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{inhale}\(\ (h_0, \pi_0,  \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x)) \) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\ident \textit{/* Symbolically evaluate source-level expressions */} \\
\ident \( \mathbf{var\ } (\pi_1, \underline{c}(y)) := eval(h_0, \pi_0, c_y)) \)\\
\ident \( \mathbf{var\ } (\pi_{2_1},\underline{e_1}(y)) := eval(h_0, \pi_1 \cup \{ \) \underline{c}\( (y)\}, e_{1_y})) \)\\
\ident [\dots] \\
\ident \( \mathbf{var\ } (\pi_{2_n},\underline{e_1}(y)) := eval(h_0, \pi_0, e_{n_y})) \)\\

\ident \( \mathbf{var\ } (\pi_3,\underline{p}(y)) := eval(h_0, \pi_{2_n}, p_y))) \)\\
\ident \( \mathbf{var\ } \pi_4 := \pi_3 \backslash \{\underline{c}(y)\} \)\\
\\
\ident \textit{/* Introduce inverse function */}\\
\ident Let  \(e^{-1}\)  be a fresh function of type  \(T \rightarrow A_1, \dots, A_n\) \\
\ident \(  \mathbf{var\ } \pi_5 :=  \pi_4 \cup \{\forall a_1: A_1, \dots, a_n: A_n \cdot c(e^{-1}(a_1, \dots, a_n))  \Rightarrow \) \\
\ident \ident \ident \(\underline{e_1}(e^{-1}(a_1, \dots, a_n)) = a_1 \ \& \ \dots \ \& \  \underline{e_n}(e^{-1}(a_1, \dots, a_n))= a_n \} \) \\
\ident \(  \mathbf{var\ } \pi_6 :=  \pi_5 \cup \{\forall x:T \cdot \underline{c}(x)  \Rightarrow e^{-1}(\underline{e_1}(x), \dots, \underline{e_n}(x)) = x \}  \) \\
\\
\ident Let  \(v\)  be a fresh value map \\
\ident \( \mathbf{var\ } h_1 :=  h_0 \cup \{pred(a_1, \dots, a_n) \mapsto \) \\
\ident \ident \ident  \([v(a_1, \dots, a_n), \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0] \}  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Inhaling a Quantified Field Permission]
   {Symbolic execution rules for inhaling a quantified predicate permission.}
\label{qpnInhale}
\end{figure}

Exhaling a nested quantified permission is done analogously. The check for the inverse function is also altered accordingly.

%exhale
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{exhale}\(\ (h_0, \pi_0, \mathbf{forall\ } x:T :: c(x) \Rightarrow  acc(pred(e_1 (x),…,e_n (x)), p(x))\) \{\\
\ident Let y be a fresh symbolic constant of type\( \ T\) \\
\\
\ident \textit{/* Check injectivity of receiver expression */} \\
\ident Let \(\ y_1, y_2\ \) be a fresh symbolic constants of Type \(\ T\) \\
\ident \(\mathbf{check \ } \pi_4 \models \underline{c}(y_1) \land \underline{c}(y_2) \land (\underline{e_1}(y_1) = \underline{e_1}(y_2)) \land \dots \land  (\underline{e_n}(y_1) = \underline{e_n}(y_2)) \Rightarrow \) \\
\ident \ident \ident \ident \(y_1 = y_2\) \\
\\
\ident \textit{/* Introduce inverse function (as above)*/}\\
\ident [\dots] \\
\\
\ident \textit{/* Remove Permissions */}\\
\ident \( \mathbf{var \ } h_1 :=  remove(h_0, \pi_6, f, \lambda a_1, \dots, a_n \cdot \underline{c}(e^{-1}(a_1, \dots, a_n)) ? \)\\ 
\ident \ident \ident  \( \underline{p}(e^{-1}(a_1, \dots, a_n)) : 0))  \) \\
\ident \textbf{return} \( (h_1, \pi_6) \) \\
\}\\ \hline
\end{tabularx}
\caption[Exhaling a Quantified Field Permission]
   {Symbolic execution rules for exhaling a quantified predicate permission.} %expand description: check, remove....
\label{qpnExhale}
\end{figure}

%remove
\begin{figure}[h]
  \centering
\begin{tabularx}{1\textwidth}{| X |}
\hline
\textbf{remove}\(\ (h_0, \pi_0, f, g) \) \{\\
\ident Let \(h_{pred} \subseteq h_0\) be all chunks in given state for predicate \(pred\) \\
\ident \textit{/* Processed chunks */} \\
\ident \( \mathbf{var \ } h'_{pred} := \emptyset \) \\
\ident \textit{/* Permission still to taken */} \\
\ident \( \mathbf{var \ } q_{needed} :=  q \)   \\
\ident \textbf{foreach} \(pred(a_1, \dots, a_n) \mapsto [v_i(a_1, \dots, a_n), q_i(a_1, \dots, a_n)] \in h_{pred}\) \textbf{do:} \\
\ident \ident \textit{/* Determine the permissions to take from this chunk */} \\
\ident \ident \( \mathbf{var \ } q_{current} := ( \lambda a_1, \dots, a_n \cdot min(q_i(a_1, \dots, a_n), q_{needed}(a_1, \dots, a_n))) \)\\
\\ 
\ident \ident \textit{/* Decrease the permissions still needed */} \\
\ident \ident \(q_{needed} := (\lambda a_1, \dots, a_n \cdot q_{needed}(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n) \)\\
\\
\ident \ident \textit{/* Add an updated chunk to the processed chunks */} \\
\ident \ident \( h'_{pred} := h'_{pred} \cup \{r.f \mapsto [v_i((a_1, \dots, a_n), (q_i(a_1, \dots, a_n) - q_{current}(a_1, \dots, a_n)] \} \)\\
\\
\ident \textit{/* Check that sufficient permissions were removed */} \\
\ident \(\mathbf{check} \pi_0 \models \forall r \cdot q_{needed}(a_1, \dots, a_n) = 0 \) \\
\ident \textbf{return} \( (h_1 \backslash h_{pred})  \cup h'_{pred} \) \\
\}\\ \hline
\end{tabularx}
\caption[Remove a Quantified Field Permission]
   {Symbolic execution rules for removing a quantified field permission. Eval. Check...}
\label{qpnRemove}
\end{figure}

The definition of removing a permission amount from a quantified expression does not need to be changed except for the filtering of the quantified chunks. After that, we again iterate through these chunks, taking permission greedily, and raising an error if not enough permission is available. The updated definition can be seen in figure %\ref{qpRemove}.

\subsection{Treatment of Symbolic Values}
The predicate snapshot is used during unfold, fold and unfolding, where unfold corresponds to a field read and fold to field write in the context of a quantified field permission.


\subsection{Rewriting Rules for Nested Quantified Permissions}
\label{rewritesN}

\begin{tabularx}{1\textwidth}{ X}
      \(\mathbf{forall \ }  x_1:T_1, \dots x_n:T_n ::  \{trs_1\}\  c_1(x_1, \dots, x_n) \Rightarrow \) \\
\ident \ident \ident     \( ( \mathbf{forall \ } x_{n+1}:T_{n+1} :: \{trs_2\} \ c_2(x_1, \dots, x_{n+1}) \Rightarrow e(x_1, \dots, x_{n+1}))\)
\\
    \( \longmapsto\)\\
\\
      \(\mathbf{forall \ }  x_1:T_1, \dots x_{n+1}:T_{n+1} ::  \{trs_1 \times trs_2\}\  \) \\ 
\ident \ident \ident \(( c_1(x_1, \dots, x_n) \:\&\&\:   \ c_2(x_1, \dots, x_{n+1}) )  \Rightarrow  e(x_1, \dots, x_{n+1}))\) \\
\end{tabularx}\\

\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}