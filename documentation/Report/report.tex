\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}

\begin{document}
\maketitle
\newpage
\section{Abstract}
\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs including shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} assosciate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a randomn access pattern in an array.

The paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language Silver. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Silver handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express pointwise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adpation of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

...section . deals with .

\section{Background}

In this section we explain

\subsection{Viper}

Viper\cite{viper} is an verification infrastructure for permission-based reasoning and enables the development of program verifiers based on permission logics.It is designed to facilitates the implementation of verification techniques for programs, allowing developers to focus on the abstraction of higher-level language features to its intermediate verifcation language. Currenlty, it includes an intermediate verification language \textit{Silver}, two automatic back-end verifiers based on it and several front-ends for programming languages.

\textit{Silver}

The two back-end verifiers are called \textit{Carbon} and \textit{Silicon}.

\textit{Carbon}  is based on verification condition generation.%continue

\textit{Silicon} is based on symbolic execution.%continue


\subsubsection{Silver}
%overview of syntax
fields, methods, functions, predicates, custom domains.

\subsubsection{Permission-based reasoning in Viper}
%Chunks

\subsection{Unbounded heap structures}

\subsubsection{Recursive Predicates}
Recursive Predicates\cite{parkinson2005separation} are typically used as part of separation logic to specify linked data structures such as lists and trees. Its definition consists of a name, a list of formal parameters and a body. The permission of the predicate may be exchanged for its body via \textit{unfold}, whereas \textit{fold} exchanges the properties of the body for the permission of the predicate. Additionally, \textit{unfolding} additionally allows to temporarily unfold a predicate.

%TODO: example please. Explicit task thing for unfolding, folding a predicate
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
inhale acc(pred(arg1, ..., argn)):\\
assume permission at most p?\\
generate snap\\
add predicate chunk
}}

\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
exhale acc(pred(arg1, ..., argn)):\\
assert p not negative\\
assert enough permission\\
remove predicate chunk\\
add predicate chunk with remaining permission if any
}}

\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
unfold acc(pred(arg1, ..., argn):\\
assert perm nonnegative\\
consume predicate permission: generates snap\\
produce predicate with obtained snap 
}}


\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
fold pred(arg1, ..., argn):\\
assume permission at most p\\
consume body: obtain snap of chunk\\
produce predicate chunk\\
}}



\subsubsection{Magic Wands}
The magic wand\cite{magicwand} A --* B is a binary connective, which allows that given assertion A is satisfied in the current state, it can be exchanged for the assertion B. Similarly to recursive predicates, the exchange can be initiated by \textit{apply}, whereas \textit{unapply} exchanges assertion B for assertion A. Viper also supports a heuristic to automate when these assertions are exchanged. This functionality can be used to keep track of partial data structures during a traversal.

%example please. Explain more closely how apply and unapply work. Cite other stuff?

%Quantified Field Permissions
\subsubsection{Quantified Field Permissions}
The generalisation of quantified permissions as defined before is building on top of the concept presented for quantified field permissions of the paper \textit{Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution}\cite{isc}.

It defines a new definition for quantified heap chunks and an approach to inhale and exhale quantified field permissions.

%Quantified Field Chunk
\subsubsection{Quantified Field Chunk}


%Inhale
\subsubsection{Inhale}
Inhaling a quantified field permissions consists of the following steps:
\begin{itemize}
\item evaluate the given terms (condition, receiver epxression, permission expression)
\item introduce a new inverse function mapping a memory location to the initial value of the forall quantifier
\item create a new field value map storing the values for the locations
\item update the heap a new heap quantified field heap chunk 
\end{itemize}

%Exhale
\subsubsection{Exhale}

\begin{itemize}
\item evaluate the given terms (condition, receiver epxression, permission expression)
\item introduce a new inverse function mapping a memory location to the initial value of the forall quantifier
\end{itemize}




\section{Quantified Predicate Permissions}

\section{Quantified Wand Permissions}

%Quantifiers
\section{Combinations of Quantifiers}
In order to avoid declaring unnecessary forall expression with the condition or dependency, it is desirable to be able to express combinations of pure and permission-based specifications. We considered the following combinations:
\begin{itemize}
\item conjunction of any mix of pure and permission-based quantifiers:
%TODO link to specific definition
\begin{equation}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))),
\end{equation}
where {\it trs} are the triggers of the forall expression, {\it c(x)} is  a boolean expression,{\it e(x)} denotes an expression which could either be a pure expression or a permission expression depending on x, in which case {\it e(x)} consists of an injective mapping to a set of locations and some permission function {\it p(x)} as described in the chapters before.

\item implication of a boolean expression and a permission-based quantifier:
%TODO: link?
\begin{equation}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x)),
\end{equation}
with the same definitions of .
\end{itemize}

Please note that forall expressions which are entirely pure are not considered in this chapter.

%TODO

We considered two ways to expand the given approach to this setting: desugaring the forall expression to the form we defined before or adapt the interpretation to allow for such things. As it is, combinations may be depending on each other, which means each conjunction as to be evaluated sequentally. As a result there is barely any gain in not desugaring the terms mentioned before. Therefoe we suggest two rewriting rules to desugare conjunctions and implications within a forall expression.

\subsection{Rewriting Rules}
A conjunction of two expression is desugared by rewriting the entire forall expreeion into two forall expressions, dublicating variables, condition and triggers. Triggers are expected to be valid for both newly generated forall expressions.

\begin{equation}
\begin{aligned}
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x)  \Rightarrow e_1(x)) \ \&\& \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x) \Rightarrow  e_1(x))
\end{aligned}
\end{equation}

An implication is rewritten to the logical equivalent of the conjunction of both conditions on the left-hand side of the implication.
\begin{equation}
	\mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x))
\end{equation}

\subsection{Implementation}
The rewriting rules are implemented in the parser. As a result they are exectued for both Carbon and Silicon.

User-given triggers are handed over. Since suitability of the triggers is not tested for each rewritten forall expression, triggers need to suite all and clauses of an expression. Pure quantifiers are not rewritten. 

%TODO
 In Carbon, triggers are generated after the rewriting step in case of empty triggers.


\section{Nested Quantifiers}
\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}