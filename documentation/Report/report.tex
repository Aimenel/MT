\title{\bf{Generalised Verification for Quantified Permissions}}
\author{
	\bf{Master Thesis Project Description} \\
        	Nadja M\"uller \\
	\\
	Supervised by Alexander Summers, Prof. Dr. Peter M\"uller\\
	 Department of Computer Science \\
	ETH Z\"urich \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{mathtools}

\begin{document}
\maketitle
\newpage
\section{Abstract}
\section{Introduction}
%viper implementation?
In order to verify heap-manipulating programs including shared mutable data structures, separation logic\cite{reynolds2002separation} and implicit frames\cite{smans2009implicit} assosciate an access permission with each memory location to reason about its state. 
Dynamic data structures may depend on a potentially unbound set of memory locations. One way to define access rights to such a structure is to introduce recursive predicates defining the permissions needed. There are however access patterns which cannot be defined as a predicate, for example a randomn access pattern in an array.

The paper Automatic Verification of Iterated Separating Conjunctions using Symbolic Execution\cite{isc} presents a solution to define permissions to a set of unbound locations regardless of the access pattern. It generalises heap chunks to hold an unbound number of locations simultaneously and encode a symbolic value per location, as well as a solution how to remove and add permissions these heap chunks.

This approach was implemented in the verification infrastructure viper \cite{viper}. It includes several front-ends which translate given programs to Viper's intermediate language Silver. Verification runs on Silicon, which is based on symbolic execution, and Carbon, a verification condition generator.

There are currently three features of Silver handling unbounded heap structures. Using predicates, it can handle data structures which are recursively defined, magic wands \cite{magicwand} can be used to keep track of partial data structure and quantified field permissions \cite{isc} allows us to express pointwise specifications. 

This project presents the generalisation of that approach. Currently, the approach mentioned supports quantified permissions of the following structure:
\begin{equation}
	\mathbf{forall} \; x:T :: c(x) ==>\mathbf{acc}( e(x).f, p(x) ) ,
\end{equation}
where {\it f} is a field of any type, {\it c(x)} is  a boolean expression,{\it e(x)} an injective reference-typed expression and {\it p(x)} a permission expression.

As a generalisation, we introduce an adpation of this solution to allow permissions to predicates\cite{predicates} and magic wands\cite{magicwand} instead of field permissions, as well as generalise the general form in order to allow nested quantifiers and combinations of pure and permission-based quantifiers.

\subsection{Outline}

...section . deals with .

\section{Background}
%viper, silver, carbon, silicon
\subsubsection{Quantified Field Permissions}
\subsubsection{Predicates}
\subsubsection{Magic Wands}
\section{Quantified Predicates}
\section{Quantified Wands}
\section{Combinations of Quantifiers}
In order to avoid declaring unnecessary forall expression with the condition or dependency, it is desirable to be able to express combinations of pure and permission-based specifications. We considered the following combinations:
\begin{itemize}
\item conjunction of any mix of pure and permission-based quantifiers:
%TODO link to specific definition
\begin{equation}
	\mathbf{forall} \; x:T :: \{trs\}\  c(x) \Rightarrow (e_1(x)\ \&\& \ e_2(x))),
\end{equation}
where {\it trs} are the triggers of the forall expression, {\it c(x)} is  a boolean expression,{\it e(x)} denotes an expression which could either be a pure expression or a permission expression depending on x, in which case {\it e(x)} consists of an injective mapping to a set of locations and some permission function {\it p(x)} as described in the chapters before.

\item implication of a boolean expression and a permission-based quantifier:
%TODO: link?
\begin{equation}
	\mathbf{forall} \; x:T ::  \{trs\}\ c_1(x) \Rightarrow (c_2(x) \Rightarrow e(x)),
\end{equation}
with the same definitions of .
\end{itemize}

Please note that forall expressions which are entirely pure are not considered in this chapter.

%TODO

We considered two ways to expand the given approach to this setting: desugaring the forall expression to the form we defined before or adapt the interpretation to allow for such things. As it is, combinations may be depending on each other, which means each conjunction as to be evaluated sequentally. As a result there is barely any gain in not desugaring the terms mentioned before. Therefoe we suggest two rewriting rules to desugare conjunctions and implications within a forall expression.

\subsection{Rewriting Rules}
A conjunction of two expression is desugared by rewriting the entire forall expreeion into two forall expressions, dublicating variables, condition and triggers. Triggers are expected to be valid for both newly generated forall expressions.

\begin{equation}
\begin{aligned}
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x)  \Rightarrow e_1(x)) \ \&\& \\
	(\mathbf{forall} \; x:T :: \{trs\}\   c(x) \Rightarrow  e_1(x))
\end{aligned}
\end{equation}

An implication is rewritten to the logical equivalent of the conjunction of both conditions on the left-hand side of the implication.
\begin{equation}
	\mathbf{forall} \; x:T ::( c_1(x) \:\&\&\: c_2(x)) \Rightarrow \mathbf{acc}(e(x).f, p(x))
\end{equation}

\subsection{Implementation}
The rewriting rules are implemented in the parser. As a result they are exectued for both Carbon and Silicon.

User-given triggers are handed over. Since suitability of the triggers is not tested for each rewritten forall expression, triggers need to suite all and clauses of an expression. Pure quantifiers are not rewritten. 

%TODO
 In Carbon, triggers are generated after the rewriting step in case of empty triggers.


\section{Nested Quantifiers}
\section{Evaluation}
\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}