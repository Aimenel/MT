Missing test cases:
- partial access rights?
- wildcards


Bugs:
injectivity.sil
------------------------------------------------
Triggers should be adapted to check whether they are dependent on the forall variable


Forall 11.11, 39.11 insufficient permissions
------------------------------------------------
There's a problem with independent precdicates and magic wands.

Weirdly: forall test01: works if you swap the requires. does not in the following order (insufficient permissions):
In hindsight, not so weird: This is due to the fact that the h(x) is less resitrictive to the access pattern. Therefore all the added permissions get taken along.

field f: Int

predicate h(a:Ref) {
	acc(a.f)
}


method test01(xs: Set[Ref], ys: Seq[Ref])
  requires forall x: Ref :: x in xs ==> acc(h(x))
  requires forall i: Int :: i in [0..|ys|) ==> acc(h(ys[i]))


  ensures forall x: Ref :: x in xs ==> acc(h(x))
  ensures forall i: Int :: i in [0..|ys|) ==> acc(h(ys[i]))
{}



    assume (forall x_4: Ref ::
      { PostMask[null, h(x_4)] }
      (xs[x_4] ==> QPMask[null, h(x_4)] == PostMask[null, h(x_4)] + FullPerm) && (!xs[x_4] ==> QPMask[null, h(x_4)] == PostMask[null, h(x_4)])
    ) && (forall x_4: Ref ::
      { QPMask[null, h(x_4)] }
      (xs[x_4] ==> QPMask[null, h(x_4)] == PostMask[null, h(x_4)] + FullPerm) && (!xs[x_4] ==> QPMask[null, h(x_4)] == PostMask[null, h(x_4)])
    );
	
	    assume (forall i_4: int ::
      { PostMask[null, h(Seq#Index(ys, i_4))] }
      (Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))] + FullPerm) && (!Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))])
    ) && (forall i_4: int ::
      { QPMask[null, h(Seq#Index(ys, i_4))] }
      (Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))] + FullPerm) && (!Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))])
    );

    assert {:msg "  Postcondition of test01 might not hold. There might be insufficient permission to access h(x). (test.sil@11.11) [13]"}
      (forall x_6: Ref ::
      
      xs[x_6] ==> Mask[null, h(x_6)] >= FullPerm
    );


    assert {:msg "  Postcondition of test01 might not hold. There might be insufficient permission to access h(ys[i]). (test.sil@12.11) [15]"}
      (forall i_6: int ::
      
      Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_6) ==> Mask[null, h(Seq#Index(ys, i_6))] >= FullPerm
    );
	
	
Solution:

IndependentLocations (All non-predicate fields && predicates not matching the pattern)

Not Predicate
assume (forall <A, B> o_2: Ref, f_4: (Field A B) ::
      
      !IsPredicateField(f_4) ==> Mask[o_2, f_4] == QPMask[o_2, f_4]
    );


    assume (forall i_4: int ::
      { PostMask[null, h(Seq#Index(ys, i_4))] }
      (Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))] + FullPerm) && (!Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))])
    ) && (forall i_4: int ::
      { QPMask[null, h(Seq#Index(ys, i_4))] }
      (Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))] + FullPerm) && (!Seq#Contains(Seq#Range(0, Seq#Length(ys)), i_4) ==> QPMask[null, h(Seq#Index(ys, i_4))] == PostMask[null, h(Seq#Index(ys, i_4))])
    );


Predicate:
	assume (forall <A, B> o_2: Ref, f_4: (Field A B) ::  
      IsPredicateField(f_4) && notThatPredicate ==> Mask[o_2, f_4] == QPMask[o_2, f_4]
    );


    assume (forall <A, B> o_2: Ref, f_4: (Field A B),  x_10:int ::
	     {QPMask[o_2, f_4], Mask[o_2, f_4], QPMask[null, p2(a_4, x_10)], Mask[null, p2(a_4, x_10)]}
      (IsPredicateField(f_4) && f_4!= p2(a_4, x_10) ==> Mask[o_2, f_4] == QPMask[o_2, f_4])
    );
	